{"version":3,"sources":["../../../src/parser/pipes/parseElements.js"],"names":["parseElementAndWhitespace","parseWhitespaceAndComments","parseElement","parseCommaElementAndWhitespace","parseCommaOperator","parseElements","props","children","context","tokenList","elements","first","nextToken","get","size","type","TokenTypes","OPERATOR_CLOSE_BRACKET","element"],"mappings":";;;;;;;AAAA;;AAEA;;AAEA;;AACA;;AACA;;;;;;;;;;AAEA,MAAMA,yBAAyB,GAAG,iBAChCC,mCADgC,EAEhCC,qBAFgC,EAGhCD,mCAHgC,CAAlC;AAMA,MAAME,8BAA8B,GAAG,iBAAKC,2BAAL,EAAyBJ,yBAAzB,CAAvC;;AAEA,MAAMK,aAAa,GAAIC,KAAD,IAAW;AAC/B,MAAI;AAAEC,IAAAA,QAAF;AAAYC,IAAAA,OAAZ;AAAqBC,IAAAA;AAArB,MAAmCH,KAAvC;AACA,MAAII,QAAQ,GAAG,EAAf;AACA,MAAIC,KAAK,GAAG,IAAZ;AACA,MAAIC,SAAS,GAAGH,SAAS,CAACI,GAAV,CAAc,CAAd,CAAhB;;AACA,SAAOJ,SAAS,CAACK,IAAV,GAAiB,CAAjB,IAAsBF,SAAS,CAACG,IAAV,KAAmBC,sBAAWC,sBAA3D,EAAmF;AACjF,QAAIC,OAAJ;;AACA,QAAIP,KAAJ,EAAW;AACTA,MAAAA,KAAK,GAAG,KAAR;AACC,OAAC;AAAEJ,QAAAA,QAAF;AAAYC,QAAAA,OAAZ;AAAqBU,QAAAA,OAArB;AAA8BT,QAAAA;AAA9B,UAA4CT,yBAAyB,CAAC;AACtEO,QAAAA,QADsE;AAEtEC,QAAAA,OAFsE;AAGtEC,QAAAA;AAHsE,OAAD,CAAtE;AAKF,KAPD,MAOO;AACL;AAAC,OAAC;AAAEF,QAAAA,QAAF;AAAYC,QAAAA,OAAZ;AAAqBU,QAAAA,OAArB;AAA8BT,QAAAA;AAA9B,UAA4CN,8BAA8B,CAAC;AAC3EI,QAAAA,QAD2E;AAE3EC,QAAAA,OAF2E;AAG3EC,QAAAA;AAH2E,OAAD,CAA3E;AAKF;;AACDC,IAAAA,QAAQ,GAAG,mBAAOQ,OAAP,EAAgBR,QAAhB,CAAX;AACAE,IAAAA,SAAS,GAAGH,SAAS,CAACI,GAAV,CAAc,CAAd,CAAZ;AACD;;AACD,yCAAYP,KAAZ;AAAmBC,IAAAA,QAAnB;AAA6BC,IAAAA,OAA7B;AAAsCE,IAAAA,QAAtC;AAAgDD,IAAAA;AAAhD;AACD,CAzBD;;eA2BeJ,a","sourcesContent":["import { append, pipe } from 'ramda'\n\nimport { TokenTypes } from '../../constants'\n\nimport parseCommaOperator from './parseCommaOperator'\nimport parseElement from './parseElement'\nimport parseWhitespaceAndComments from './parseWhitespaceAndComments'\n\nconst parseElementAndWhitespace = pipe(\n  parseWhitespaceAndComments,\n  parseElement,\n  parseWhitespaceAndComments\n)\n\nconst parseCommaElementAndWhitespace = pipe(parseCommaOperator, parseElementAndWhitespace)\n\nconst parseElements = (props) => {\n  let { children, context, tokenList } = props\n  let elements = []\n  let first = true\n  let nextToken = tokenList.get(0)\n  while (tokenList.size > 0 && nextToken.type !== TokenTypes.OPERATOR_CLOSE_BRACKET) {\n    let element\n    if (first) {\n      first = false\n      ;({ children, context, element, tokenList } = parseElementAndWhitespace({\n        children,\n        context,\n        tokenList\n      }))\n    } else {\n      ;({ children, context, element, tokenList } = parseCommaElementAndWhitespace({\n        children,\n        context,\n        tokenList\n      }))\n    }\n    elements = append(element, elements)\n    nextToken = tokenList.get(0)\n  }\n  return { ...props, children, context, elements, tokenList }\n}\n\nexport default parseElements\n"],"file":"parseElements.js"}