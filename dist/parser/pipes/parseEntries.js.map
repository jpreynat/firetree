{"version":3,"sources":["../../../src/parser/pipes/parseEntries.js"],"names":["parseEntryAndWhitespace","parseWhitespaceAndComments","parseEntry","parseCommaEntryAndWhitespace","parseCommaOperator","parseEntries","props","children","context","tokenList","entries","first","nextToken","get","size","type","TokenTypes","OPERATOR_CLOSE_CURLY_BRACE","entry"],"mappings":";;;;;;;AAAA;;AAEA;;AAEA;;AACA;;AACA;;;;;;;;;;AAEA,MAAMA,uBAAuB,GAAG,iBAC9BC,mCAD8B,EAE9BC,mBAF8B,EAG9BD,mCAH8B,CAAhC;AAMA,MAAME,4BAA4B,GAAG,iBAAKC,2BAAL,EAAyBJ,uBAAzB,CAArC;;AAEA,MAAMK,YAAY,GAAIC,KAAD,IAAW;AAC9B,MAAI;AAAEC,IAAAA,QAAF;AAAYC,IAAAA,OAAZ;AAAqBC,IAAAA;AAArB,MAAmCH,KAAvC;AACA,MAAII,OAAO,GAAG,EAAd;AACA,MAAIC,KAAK,GAAG,IAAZ;AACA,MAAIC,SAAS,GAAGH,SAAS,CAACI,GAAV,CAAc,CAAd,CAAhB;;AACA,SAAOJ,SAAS,CAACK,IAAV,GAAiB,CAAjB,IAAsBF,SAAS,CAACG,IAAV,KAAmBC,sBAAWC,0BAA3D,EAAuF;AACrF,QAAIC,KAAJ;;AACA,QAAIP,KAAJ,EAAW;AACTA,MAAAA,KAAK,GAAG,KAAR;AACC,OAAC;AAAEJ,QAAAA,QAAF;AAAYC,QAAAA,OAAZ;AAAqBU,QAAAA,KAArB;AAA4BT,QAAAA;AAA5B,UAA0CT,uBAAuB,CAAC;AAClEO,QAAAA,QADkE;AAElEC,QAAAA,OAFkE;AAGlEC,QAAAA;AAHkE,OAAD,CAAlE;AAKF,KAPD,MAOO;AACL;AAAC,OAAC;AAAEF,QAAAA,QAAF;AAAYC,QAAAA,OAAZ;AAAqBU,QAAAA,KAArB;AAA4BT,QAAAA;AAA5B,UAA0CN,4BAA4B,CAAC;AACvEI,QAAAA,QADuE;AAEvEC,QAAAA,OAFuE;AAGvEC,QAAAA;AAHuE,OAAD,CAAvE;AAKF;;AACDC,IAAAA,OAAO,GAAG,mBAAOQ,KAAP,EAAcR,OAAd,CAAV;AACAE,IAAAA,SAAS,GAAGH,SAAS,CAACI,GAAV,CAAc,CAAd,CAAZ;AACD;;AACD,yCAAYP,KAAZ;AAAmBC,IAAAA,QAAnB;AAA6BC,IAAAA,OAA7B;AAAsCE,IAAAA,OAAtC;AAA+CD,IAAAA;AAA/C;AACD,CAzBD;;eA2BeJ,Y","sourcesContent":["import { append, pipe } from 'ramda'\n\nimport { TokenTypes } from '../../constants'\n\nimport parseCommaOperator from './parseCommaOperator'\nimport parseEntry from './parseEntry'\nimport parseWhitespaceAndComments from './parseWhitespaceAndComments'\n\nconst parseEntryAndWhitespace = pipe(\n  parseWhitespaceAndComments,\n  parseEntry,\n  parseWhitespaceAndComments\n)\n\nconst parseCommaEntryAndWhitespace = pipe(parseCommaOperator, parseEntryAndWhitespace)\n\nconst parseEntries = (props) => {\n  let { children, context, tokenList } = props\n  let entries = []\n  let first = true\n  let nextToken = tokenList.get(0)\n  while (tokenList.size > 0 && nextToken.type !== TokenTypes.OPERATOR_CLOSE_CURLY_BRACE) {\n    let entry\n    if (first) {\n      first = false\n      ;({ children, context, entry, tokenList } = parseEntryAndWhitespace({\n        children,\n        context,\n        tokenList\n      }))\n    } else {\n      ;({ children, context, entry, tokenList } = parseCommaEntryAndWhitespace({\n        children,\n        context,\n        tokenList\n      }))\n    }\n    entries = append(entry, entries)\n    nextToken = tokenList.get(0)\n  }\n  return { ...props, children, context, entries, tokenList }\n}\n\nexport default parseEntries\n"],"file":"parseEntries.js"}