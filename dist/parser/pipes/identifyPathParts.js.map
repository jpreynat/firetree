{"version":3,"sources":["../../../src/parser/pipes/identifyPathParts.js"],"names":["PATH_PART_IDENTIFIERS","PathPartExpression","PathPartVariable","PathPartWord","identifyPathPartNode","identifyPathPart","children","context","rest","nextChild","pathPart","identifyPathParts","props","path"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;;;;;;;;;;;;;AAEA,MAAMA,qBAAqB,GAAG,CAACC,2BAAD,EAAqBC,yBAArB,EAAuCC,qBAAvC,CAA9B;AACA,MAAMC,oBAAoB,GAAG,4BAAiBJ,qBAAjB,CAA7B;;AAEA,MAAMK,gBAAgB,GAAG,UAAoC;AAAA,MAAnC;AAAEC,IAAAA,QAAF;AAAYC,IAAAA;AAAZ,GAAmC;AAAA,MAAXC,IAAW;;AAC3D,QAAMC,SAAS,GAAG,iBAAKH,QAAL,CAAlB;AACA,QAAMI,QAAQ,GAAGN,oBAAoB,CAACG,OAAD,EAAUE,SAAV,CAArC;AACAH,EAAAA,QAAQ,GAAG,iBAAKA,QAAL,CAAX;AACA,yCAAYE,IAAZ;AAAkBF,IAAAA,QAAlB;AAA4BC,IAAAA,OAA5B;AAAqCG,IAAAA;AAArC;AACD,CALD;;AAOA,MAAMC,iBAAiB,GAAIC,KAAD,IAAW;AACnC,MAAI;AAAEN,IAAAA,QAAF;AAAYC,IAAAA;AAAZ,MAAwBK,KAA5B;AACA,MAAIC,IAAI,GAAG,EAAX;AACA,MAAIJ,SAAS,GAAG,iBAAKH,QAAL,CAAhB;;AACA,SAAO,mBAAOA,QAAP,IAAmB,CAAnB,IAAwB,sBAAWN,qBAAX,EAAkCS,SAAlC,CAA/B,EAA6E;AAC3E,QAAIC,QAAJ;AACC,KAAC;AAAEJ,MAAAA,QAAF;AAAYC,MAAAA,OAAZ;AAAqBG,MAAAA;AAArB,QAAkCL,gBAAgB,CAAC;AACnDC,MAAAA,QADmD;AAEnDC,MAAAA;AAFmD,KAAD,CAAnD;AAIDM,IAAAA,IAAI,GAAG,mBAAOH,QAAP,EAAiBG,IAAjB,CAAP;AACAJ,IAAAA,SAAS,GAAG,iBAAKH,QAAL,CAAZ;AACD;;AACD,yCAAYM,KAAZ;AAAmBN,IAAAA,QAAnB;AAA6BC,IAAAA,OAA7B;AAAsCM,IAAAA;AAAtC;AACD,CAdD;;eAgBeF,iB","sourcesContent":["import { append, head, length, tail } from 'ramda'\n\nimport PathPartExpression from '../nodes/PathPartExpression'\nimport PathPartVariable from '../nodes/PathPartVariable'\nimport PathPartWord from '../nodes/PathPartWord'\nimport { identifyNextNode, isNextNode } from '../util'\n\nconst PATH_PART_IDENTIFIERS = [PathPartExpression, PathPartVariable, PathPartWord]\nconst identifyPathPartNode = identifyNextNode(PATH_PART_IDENTIFIERS)\n\nconst identifyPathPart = ({ children, context, ...rest }) => {\n  const nextChild = head(children)\n  const pathPart = identifyPathPartNode(context, nextChild)\n  children = tail(children)\n  return { ...rest, children, context, pathPart }\n}\n\nconst identifyPathParts = (props) => {\n  let { children, context } = props\n  let path = []\n  let nextChild = head(children)\n  while (length(children) > 0 && isNextNode(PATH_PART_IDENTIFIERS, nextChild)) {\n    let pathPart\n    ;({ children, context, pathPart } = identifyPathPart({\n      children,\n      context\n    }))\n    path = append(pathPart, path)\n    nextChild = head(children)\n  }\n  return { ...props, children, context, path }\n}\n\nexport default identifyPathParts\n"],"file":"identifyPathParts.js"}