{"version":3,"sources":["../../../src/parser/nodes/ParenthesesExpression.js"],"names":["parseParenthesesExpressionTokens","parseOpenParenthesisOperator","parseWhitespaceAndComments","parseExpression","parseCloseParenthesisOperator","createParenthesesExpression","identifyParenthesesExpressionChildren","expectOpenParenthesisOperator","skipWhitespaceAndComments","identifyExpression","expectCloseParenthesisOperator","ParenthesesExpression","identify","context","node","children","is","value","type","NodeTypes","PARENTHESES_EXPRESSION","parse","tokenList","test","prevExpression","operatorToken","TokenTypes","OPERATOR_OPEN_PARENTHESIS","ParserTypes","EXPRESSION"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;AAEA,MAAMA,gCAAgC,GAAG,iBACvCC,qCADuC,EAEvCC,mCAFuC,EAGvCC,wBAHuC,EAIvCD,mCAJuC,EAKvCE,sCALuC,EAMvCC,oCANuC,CAAzC;AASA,MAAMC,qCAAqC,GAAG,iBAC5CC,sCAD4C,EAE5CC,kCAF4C,EAG5CC,2BAH4C,EAI5CD,kCAJ4C,EAK5CE,uCAL4C,CAA9C;AAQA,MAAMC,qBAAqB,GAAG;AAC5BC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KACR,0EACKR,qCAAqC,iCACnCQ,IADmC;AAEtCD,IAAAA;AAFsC,KAD1C;AAKEE,IAAAA,QAAQ,EAAED,IAAI,CAACC;AALjB,KAF0B;AAS5BC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,sBATrB;AAU5BC,EAAAA,KAAK,EAAE,CAACR,OAAD,EAAUS,SAAV,KACLtB,gCAAgC,CAAC;AAAEe,IAAAA,QAAQ,EAAE,EAAZ;AAAgBF,IAAAA,OAAhB;AAAyBS,IAAAA;AAAzB,GAAD,CAXN;AAY5BC,EAAAA,IAAI,EAAE,CAACV,OAAD,EAAUS,SAAV,EAAqBE,cAAc,GAAG,IAAtC,KAA+C;AACnD,QAAIA,cAAJ,EAAoB;AAClB;AACA,aAAO,KAAP;AACD;;AACD,UAAMC,aAAa,GAAG,6BAAkBH,SAAlB,EAA6B,kCAAuBA,SAAvB,CAA7B,CAAtB;AACA,WAAOG,aAAa,IAAIA,aAAa,CAACP,IAAd,KAAuBQ,sBAAWC,yBAA1D;AACD,GAnB2B;AAoB5BT,EAAAA,IAAI,EAAEU,uBAAYC;AApBU,CAA9B;eAuBelB,qB","sourcesContent":["import { pipe } from 'ramda'\n\nimport { NodeTypes, ParserTypes, TokenTypes } from '../../constants'\nimport createParenthesesExpression from '../pipes/createParenthesesExpression'\nimport expectCloseParenthesisOperator from '../pipes/expectCloseParenthesisOperator'\nimport expectOpenParenthesisOperator from '../pipes/expectOpenParenthesisOperator'\nimport identifyExpression from '../pipes/identifyExpression'\nimport parseCloseParenthesisOperator from '../pipes/parseCloseParenthesisOperator'\nimport parseExpression from '../pipes/parseExpression'\nimport parseOpenParenthesisOperator from '../pipes/parseOpenParenthesisOperator'\nimport parseWhitespaceAndComments from '../pipes/parseWhitespaceAndComments'\nimport skipWhitespaceAndComments from '../pipes/skipWhitespaceAndComments'\nimport { findNextRealToken, findNextRealTokenIndex } from '../util'\n\nconst parseParenthesesExpressionTokens = pipe(\n  parseOpenParenthesisOperator,\n  parseWhitespaceAndComments,\n  parseExpression,\n  parseWhitespaceAndComments,\n  parseCloseParenthesisOperator,\n  createParenthesesExpression\n)\n\nconst identifyParenthesesExpressionChildren = pipe(\n  expectOpenParenthesisOperator,\n  skipWhitespaceAndComments,\n  identifyExpression,\n  skipWhitespaceAndComments,\n  expectCloseParenthesisOperator\n)\n\nconst ParenthesesExpression = {\n  identify: (context, node) =>\n    createParenthesesExpression({\n      ...identifyParenthesesExpressionChildren({\n        ...node,\n        context\n      }),\n      children: node.children\n    }),\n  is: (value) => value && value.type === NodeTypes.PARENTHESES_EXPRESSION,\n  parse: (context, tokenList) =>\n    parseParenthesesExpressionTokens({ children: [], context, tokenList }),\n  test: (context, tokenList, prevExpression = null) => {\n    if (prevExpression) {\n      // In this case, it's a CallExpression\n      return false\n    }\n    const operatorToken = findNextRealToken(tokenList, findNextRealTokenIndex(tokenList))\n    return operatorToken && operatorToken.type === TokenTypes.OPERATOR_OPEN_PARENTHESIS\n  },\n  type: ParserTypes.EXPRESSION\n}\n\nexport default ParenthesesExpression\n"],"file":"ParenthesesExpression.js"}