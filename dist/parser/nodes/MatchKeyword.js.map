{"version":3,"sources":["../../../src/parser/nodes/MatchKeyword.js"],"names":["MatchKeyword","identify","context","node","is","value","type","NodeTypes","KEYWORD","name","Keywords","MATCH","parse","tokenList","nextToken","get","Error","TokenTypes","KEYWORD_MATCH","lastLineCharacterCount","lineCount","test","firstToken","ParserTypes"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;;;AAEA,MAAMA,YAAY,GAAG;AACnBC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KAAmBA,IADV;AAEnBC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,OAAlC,IAA6CH,KAAK,CAACI,IAAN,KAAeC,oBAASC,KAFjE;AAGnBC,EAAAA,KAAK,EAAE,CAACV,OAAD,EAAUW,SAAV,KAAwB;AAC7B,UAAMC,SAAS,GAAGD,SAAS,CAACE,GAAV,CAAc,CAAd,CAAlB;;AACA,QAAI,CAACD,SAAL,EAAgB;AACd,YAAM,IAAIE,KAAJ,CAAW,qBAAoBN,oBAASC,KAAM,yCAA9C,CAAN;AACD;;AACD,QAAIG,SAAS,CAACR,IAAV,KAAmBW,sBAAWC,aAAlC,EAAiD;AAC/C,YAAM;AAAEC,QAAAA,sBAAF;AAA0BC,QAAAA;AAA1B,UAAwC,gCAAqBlB,OAArB,EAA8BW,SAA9B,CAA9C;AACA,YAAM,IAAIG,KAAJ,CACH,qBAAoBN,oBAASC,KAAM,yBAClCE,SAAS,CAACE,GAAV,CAAc,CAAd,EAAiBV,KAClB,QAAOe,SAAU,IAAGD,sBAAuB,EAHxC,CAAN;AAKD;;AACD,WAAO,iCAAmB;AACxBN,MAAAA,SAAS,EAAE,kBAAM,CAAN,EAAS,CAAT,EAAYA,SAAZ;AADa,KAAnB,CAAP;AAGD,GAnBkB;AAoBnBQ,EAAAA,IAAI,EAAE,CAACnB,OAAD,EAAUW,SAAV,KAAwB;AAC5B,UAAMS,UAAU,GAAGT,SAAS,CAACE,GAAV,CAAc,CAAd,CAAnB;AACA,WAAOO,UAAU,CAAChB,IAAX,KAAoBW,sBAAWC,aAAtC;AACD,GAvBkB;AAwBnBZ,EAAAA,IAAI,EAAEiB,uBAAYf;AAxBC,CAArB;eA2BeR,Y","sourcesContent":["import { slice } from 'ramda'\n\nimport { Keywords, NodeTypes, ParserTypes, TokenTypes } from '../../constants'\nimport createMatchKeyword from '../pipes/createMatchKeyword'\nimport { getTokenListPosition } from '../util'\n\nconst MatchKeyword = {\n  identify: (context, node) => node,\n  is: (value) => value && value.type === NodeTypes.KEYWORD && value.name === Keywords.MATCH,\n  parse: (context, tokenList) => {\n    const nextToken = tokenList.get(0)\n    if (!nextToken) {\n      throw new Error(`Expected keyword '${Keywords.MATCH}'. Instead reached the end of the file.`)\n    }\n    if (nextToken.type !== TokenTypes.KEYWORD_MATCH) {\n      const { lastLineCharacterCount, lineCount } = getTokenListPosition(context, tokenList)\n      throw new Error(\n        `Expected keyword '${Keywords.MATCH}'. Instead was given '${\n          tokenList.get(0).value\n        }' at ${lineCount}:${lastLineCharacterCount}`\n      )\n    }\n    return createMatchKeyword({\n      tokenList: slice(0, 1, tokenList)\n    })\n  },\n  test: (context, tokenList) => {\n    const firstToken = tokenList.get(0)\n    return firstToken.type === TokenTypes.KEYWORD_MATCH\n  },\n  type: ParserTypes.KEYWORD\n}\n\nexport default MatchKeyword\n"],"file":"MatchKeyword.js"}