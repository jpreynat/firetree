{"version":3,"sources":["../../../src/parser/nodes/Range.js"],"names":["START_PARSERS","Identifier","Literal","parseRangeTokens","parseStart","parseWhitespaceAndComments","parseColonOperator","parseEnd","createRange","identifyRangeChildren","identifyStart","skipWhitespaceAndComments","expectColonOperator","identifyEnd","Range","identify","context","node","children","is","value","type","NodeTypes","RANGE","parse","tokenList","test","prevExpression","operatorToken","TokenTypes","OPERATOR_COLON"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;;;;;;;;;AAEA,MAAMA,aAAa,GAAG,CAACC,mBAAD,EAAaC,gBAAb,CAAtB;AAEA,MAAMC,gBAAgB,GAAG,iBACvBC,mBADuB,EAEvBC,mCAFuB,EAGvBC,2BAHuB,EAIvBD,mCAJuB,EAKvBE,iBALuB,EAMvBC,oBANuB,CAAzB;AASA,MAAMC,qBAAqB,GAAG,iBAC5BC,sBAD4B,EAE5BC,kCAF4B,EAG5BC,4BAH4B,EAI5BD,kCAJ4B,EAK5BE,oBAL4B,CAA9B;AAQA,MAAMC,KAAK,GAAG;AACZC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KACR,0DACKR,qBAAqB,iCACnBQ,IADmB;AAEtBD,IAAAA;AAFsB,KAD1B;AAKEE,IAAAA,QAAQ,EAAED,IAAI,CAACC;AALjB,KAFU;AASZC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,KATrC;AAUZC,EAAAA,KAAK,EAAE,CAACR,OAAD,EAAUS,SAAV,KAAwBtB,gBAAgB,CAAC;AAAEe,IAAAA,QAAQ,EAAE,EAAZ;AAAgBF,IAAAA,OAAhB;AAAyBS,IAAAA;AAAzB,GAAD,CAVnC;AAWZC,EAAAA,IAAI,EAAE,CAACV,OAAD,EAAUS,SAAV,EAAqBE,cAAc,GAAG,IAAtC,KAA+C;AACnD,QAAI,CAACA,cAAL,EAAqB;AACnB,UAAI,CAAC,wBAAa3B,aAAb,EAA4BgB,OAA5B,EAAqCS,SAArC,CAAL,EAAsD;AACpD,eAAO,KAAP;AACD;AACF;;AACD,UAAMG,aAAa,GAAG,6BAAkBH,SAAlB,EAA6BE,cAAc,GAAG,CAAH,GAAO,CAAlD,CAAtB;AACA,WAAOC,aAAa,CAACP,IAAd,KAAuBQ,sBAAWC,cAAzC;AACD;AAnBW,CAAd;eAsBehB,K","sourcesContent":["import { pipe } from 'ramda'\n\nimport { NodeTypes, TokenTypes } from '../../constants'\nimport createRange from '../pipes/createRange'\nimport expectColonOperator from '../pipes/expectColonOperator'\nimport identifyEnd from '../pipes/identifyEnd'\nimport identifyStart from '../pipes/identifyStart'\nimport parseColonOperator from '../pipes/parseColonOperator'\nimport parseEnd from '../pipes/parseEnd'\nimport parseStart from '../pipes/parseStart'\nimport parseWhitespaceAndComments from '../pipes/parseWhitespaceAndComments'\nimport skipWhitespaceAndComments from '../pipes/skipWhitespaceAndComments'\nimport { findNextRealToken, testNextNode } from '../util'\n\nimport Identifier from './Identifier'\nimport Literal from './Literal'\n\nconst START_PARSERS = [Identifier, Literal]\n\nconst parseRangeTokens = pipe(\n  parseStart,\n  parseWhitespaceAndComments,\n  parseColonOperator,\n  parseWhitespaceAndComments,\n  parseEnd,\n  createRange\n)\n\nconst identifyRangeChildren = pipe(\n  identifyStart,\n  skipWhitespaceAndComments,\n  expectColonOperator,\n  skipWhitespaceAndComments,\n  identifyEnd\n)\n\nconst Range = {\n  identify: (context, node) =>\n    createRange({\n      ...identifyRangeChildren({\n        ...node,\n        context\n      }),\n      children: node.children\n    }),\n  is: (value) => value && value.type === NodeTypes.RANGE,\n  parse: (context, tokenList) => parseRangeTokens({ children: [], context, tokenList }),\n  test: (context, tokenList, prevExpression = null) => {\n    if (!prevExpression) {\n      if (!testNextNode(START_PARSERS, context, tokenList)) {\n        return false\n      }\n    }\n    const operatorToken = findNextRealToken(tokenList, prevExpression ? 0 : 1)\n    return operatorToken.type === TokenTypes.OPERATOR_COLON\n  }\n}\n\nexport default Range\n"],"file":"Range.js"}