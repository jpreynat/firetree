{"version":3,"sources":["../../../src/parser/nodes/LetDeclaration.js"],"names":["parseLetDelcarationTokens","parseLetKeyword","parseWhitespaceAndComments","parseIdentifier","parseAssignmentOperator","parseInit","parseOptionalSemicolonOperator","createLetDeclaration","identifyLetDeclarationChildren","expectLetKeyword","skipWhitespaceAndComments","identifyIdentifier","expectAssignmentOperator","identifyInit","skipSemicolonOperator","LetDeclaration","identify","context","node","children","is","value","type","NodeTypes","LET_DECLARATION","parse","tokenList","test","firstToken","get","TokenTypes","KEYWORD_LET","ParserTypes","DECLARATION"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;AAEA,MAAMA,yBAAyB,GAAG,iBAChCC,wBADgC,EAEhCC,mCAFgC,EAGhCC,wBAHgC,EAIhCD,mCAJgC,EAKhCE,gCALgC,EAMhCF,mCANgC,EAOhCG,kBAPgC,EAQhCH,mCARgC,EAShCI,uCATgC,EAUhCC,6BAVgC,CAAlC;AAaA,MAAMC,8BAA8B,GAAG,iBACrCC,yBADqC,EAErCC,kCAFqC,EAGrCC,2BAHqC,EAIrCD,kCAJqC,EAKrCE,iCALqC,EAMrCF,kCANqC,EAOrCG,qBAPqC,EAQrCH,kCARqC,EASrCI,8BATqC,CAAvC;AAYA,MAAMC,cAAc,GAAG;AACrBC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KACR,mEACKV,8BAA8B,iCAC5BU,IAD4B;AAE/BD,IAAAA;AAF+B,KADnC;AAKEE,IAAAA,QAAQ,EAAED,IAAI,CAACC;AALjB,KAFmB;AASrBC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,eAT5B;AAUrBC,EAAAA,KAAK,EAAE,CAACR,OAAD,EAAUS,SAAV,KAAwB1B,yBAAyB,CAAC;AAAEmB,IAAAA,QAAQ,EAAE,EAAZ;AAAgBF,IAAAA,OAAhB;AAAyBS,IAAAA;AAAzB,GAAD,CAVnC;AAWrBC,EAAAA,IAAI,EAAE,CAACV,OAAD,EAAUS,SAAV,KAAwB;AAC5B,UAAME,UAAU,GAAGF,SAAS,CAACG,GAAV,CAAc,CAAd,CAAnB;AACA,WAAOD,UAAU,CAACN,IAAX,KAAoBQ,sBAAWC,WAAtC;AACD,GAdoB;AAerBT,EAAAA,IAAI,EAAEU,uBAAYC;AAfG,CAAvB;eAkBelB,c","sourcesContent":["import { pipe } from 'ramda'\n\nimport { NodeTypes, ParserTypes, TokenTypes } from '../../constants'\nimport createLetDeclaration from '../pipes/createLetDeclaration'\nimport expectAssignmentOperator from '../pipes/expectAssignmentOperator'\nimport expectLetKeyword from '../pipes/expectLetKeyword'\nimport identifyIdentifier from '../pipes/identifyIdentifier'\nimport identifyInit from '../pipes/identifyInit'\nimport parseAssignmentOperator from '../pipes/parseAssignmentOperator'\nimport parseIdentifier from '../pipes/parseIdentifier'\nimport parseInit from '../pipes/parseInit'\nimport parseLetKeyword from '../pipes/parseLetKeyword'\nimport parseOptionalSemicolonOperator from '../pipes/parseOptionalSemicolonOperator'\nimport parseWhitespaceAndComments from '../pipes/parseWhitespaceAndComments'\nimport skipSemicolonOperator from '../pipes/skipSemicolonOperator'\nimport skipWhitespaceAndComments from '../pipes/skipWhitespaceAndComments'\n\nconst parseLetDelcarationTokens = pipe(\n  parseLetKeyword,\n  parseWhitespaceAndComments,\n  parseIdentifier,\n  parseWhitespaceAndComments,\n  parseAssignmentOperator,\n  parseWhitespaceAndComments,\n  parseInit,\n  parseWhitespaceAndComments,\n  parseOptionalSemicolonOperator,\n  createLetDeclaration\n)\n\nconst identifyLetDeclarationChildren = pipe(\n  expectLetKeyword,\n  skipWhitespaceAndComments,\n  identifyIdentifier,\n  skipWhitespaceAndComments,\n  expectAssignmentOperator,\n  skipWhitespaceAndComments,\n  identifyInit,\n  skipWhitespaceAndComments,\n  skipSemicolonOperator\n)\n\nconst LetDeclaration = {\n  identify: (context, node) =>\n    createLetDeclaration({\n      ...identifyLetDeclarationChildren({\n        ...node,\n        context\n      }),\n      children: node.children\n    }),\n  is: (value) => value && value.type === NodeTypes.LET_DECLARATION,\n  parse: (context, tokenList) => parseLetDelcarationTokens({ children: [], context, tokenList }),\n  test: (context, tokenList) => {\n    const firstToken = tokenList.get(0)\n    return firstToken.type === TokenTypes.KEYWORD_LET\n  },\n  type: ParserTypes.DECLARATION\n}\n\nexport default LetDeclaration\n"],"file":"LetDeclaration.js"}