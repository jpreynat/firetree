{"version":3,"sources":["../../../src/parser/nodes/AssignmentExpression.js"],"names":["parseLeft","props","children","context","prevExpression","tokenList","left","Identifier","parse","parsedTokenList","ast","size","parseAssignmentExpressionTokens","parseWhitespaceAndComments","parseAssignmentOperator","parseRight","createAssignmentExpression","identifyAssignmentExpressionChildren","identifyLeftIdentifier","skipWhitespaceAndComments","identifyAssignmentOperator","identifyRight","AssignmentExpression","identify","node","is","value","type","NodeTypes","ASSIGNMENT_EXPRESSION","test","identifierToken","TokenTypes","IDENTIFIER","operatorToken","OPERATOR_ASSIGNMENT","ParserTypes","EXPRESSION"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;;;;;;;;;AAEA;AACA,MAAMA,SAAS,GAAIC,KAAD,IAAW;AAC3B,QAAM;AAAEC,IAAAA,QAAF;AAAYC,IAAAA,OAAZ;AAAqBC,IAAAA,cAArB;AAAqCC,IAAAA;AAArC,MAAmDJ,KAAzD;;AACA,MAAIG,cAAJ,EAAoB;AAClB,2CACKH,KADL;AAEEC,MAAAA,QAAQ,EAAE,mBAAOE,cAAP,EAAuBF,QAAvB,CAFZ;AAGEI,MAAAA,IAAI,EAAEF;AAHR;AAKD;;AACD,QAAME,IAAI,GAAGC,oBAAWC,KAAX,CAAiBL,OAAjB,EAA0BE,SAA1B,CAAb;;AACA,QAAMI,eAAe,GAAG,gCAAkBN,OAAlB,EAA2B;AAAEO,IAAAA,GAAG,EAAEJ;AAAP,GAA3B,CAAxB;AACA,yCACKL,KADL;AAEEC,IAAAA,QAAQ,EAAE,mBAAOI,IAAP,EAAaJ,QAAb,CAFZ;AAGEI,IAAAA,IAHF;AAIED,IAAAA,SAAS,EAAE,kBAAMI,eAAe,CAACE,IAAtB,EAA4BN,SAAS,CAACM,IAAtC,EAA4CN,SAA5C;AAJb;AAMD,CAjBD;;AAmBA,MAAMO,+BAA+B,GAAG,iBACtCZ,SADsC,EAEtCa,mCAFsC,EAGtCC,gCAHsC,EAItCD,mCAJsC,EAKtCE,mBALsC,EAMtCC,mCANsC,CAAxC;AASA,MAAMC,oCAAoC,GAAG,iBAC3CC,+BAD2C,EAE3CC,kCAF2C,EAG3CC,mCAH2C,EAI3CD,kCAJ2C,EAK3CE,sBAL2C,CAA7C;AAQA,MAAMC,oBAAoB,GAAG;AAC3BC,EAAAA,QAAQ,EAAE,CAACpB,OAAD,EAAUqB,IAAV,KACR,yEACKP,oCAAoC,iCAClCO,IADkC;AAErCrB,IAAAA;AAFqC,KADzC;AAKED,IAAAA,QAAQ,EAAEsB,IAAI,CAACtB;AALjB,KAFyB;AAS3BuB,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,qBATtB;AAU3B;AACA;AACA;AACArB,EAAAA,KAAK,EAAE,CAACL,OAAD,EAAUE,SAAV,EAAqBD,cAAc,GAAG,IAAtC,KACLQ,+BAA+B,CAAC;AAC9BV,IAAAA,QAAQ,EAAE,EADoB;AAE9BC,IAAAA,OAF8B;AAG9BC,IAAAA,cAH8B;AAI9BC,IAAAA;AAJ8B,GAAD,CAdN;AAqB3ByB,EAAAA,IAAI,EAAE,CAAC3B,OAAD,EAAUE,SAAV,EAAqBD,cAAc,GAAG,IAAtC,KAA+C;AACnD,QAAI,CAACA,cAAL,EAAqB;AACnB;AACA;AACA,YAAM2B,eAAe,GAAG,6BAAkB1B,SAAlB,CAAxB;;AACA,UAAI,CAAC0B,eAAD,IAAoBA,eAAe,CAACJ,IAAhB,KAAyBK,sBAAWC,UAA5D,EAAwE;AACtE,eAAO,KAAP;AACD;AACF;;AACD,UAAMC,aAAa,GAAG,6BACpB7B,SADoB,EAEpB,kCAAuBA,SAAvB,KAAqCD,cAAc,GAAG,CAAH,GAAO,CAA1D,CAFoB,CAAtB;AAIA,WAAO8B,aAAa,IAAIA,aAAa,CAACP,IAAd,KAAuBK,sBAAWG,mBAA1D;AACD,GAnC0B;AAqC3B;AACAR,EAAAA,IAAI,EAAES,uBAAYC;AAtCS,CAA7B;eAyCef,oB","sourcesContent":["import { append, pipe, slice } from 'ramda'\n\nimport { NodeTypes, ParserTypes, TokenTypes } from '../../constants'\nimport generateTokenList from '../../generator/generateTokenList'\nimport createAssignmentExpression from '../pipes/createAssignmentExpression'\nimport identifyAssignmentOperator from '../pipes/identifyAssignmentOperator'\nimport identifyLeftIdentifier from '../pipes/identifyLeftIdentifier'\nimport identifyRight from '../pipes/identifyRight'\nimport parseAssignmentOperator from '../pipes/parseAssignmentOperator'\nimport parseRight from '../pipes/parseRight'\nimport parseWhitespaceAndComments from '../pipes/parseWhitespaceAndComments'\nimport skipWhitespaceAndComments from '../pipes/skipWhitespaceAndComments'\nimport { findNextRealToken, findNextRealTokenIndex } from '../util'\n\nimport Identifier from './Identifier'\n\n// NOTE BRN: The left of an AssignmentExpression MUST be an identifier\nconst parseLeft = (props) => {\n  const { children, context, prevExpression, tokenList } = props\n  if (prevExpression) {\n    return {\n      ...props,\n      children: append(prevExpression, children),\n      left: prevExpression\n    }\n  }\n  const left = Identifier.parse(context, tokenList)\n  const parsedTokenList = generateTokenList(context, { ast: left })\n  return {\n    ...props,\n    children: append(left, children),\n    left,\n    tokenList: slice(parsedTokenList.size, tokenList.size, tokenList)\n  }\n}\n\nconst parseAssignmentExpressionTokens = pipe(\n  parseLeft,\n  parseWhitespaceAndComments,\n  parseAssignmentOperator,\n  parseWhitespaceAndComments,\n  parseRight,\n  createAssignmentExpression\n)\n\nconst identifyAssignmentExpressionChildren = pipe(\n  identifyLeftIdentifier,\n  skipWhitespaceAndComments,\n  identifyAssignmentOperator,\n  skipWhitespaceAndComments,\n  identifyRight\n)\n\nconst AssignmentExpression = {\n  identify: (context, node) =>\n    createAssignmentExpression({\n      ...identifyAssignmentExpressionChildren({\n        ...node,\n        context\n      }),\n      children: node.children\n    }),\n  is: (value) => value && value.type === NodeTypes.ASSIGNMENT_EXPRESSION,\n  // TODO BRN: Might be able to insert methods here for assoc, remove, etc\n  // these methods would need to recalculate the values of the node. This is not\n  // the same as an original parse, instead,\n  parse: (context, tokenList, prevExpression = null) =>\n    parseAssignmentExpressionTokens({\n      children: [],\n      context,\n      prevExpression,\n      tokenList\n    }),\n\n  test: (context, tokenList, prevExpression = null) => {\n    if (!prevExpression) {\n      // The first real token will be the identifier (can only be a single identifier\n      // in firestore rules)\n      const identifierToken = findNextRealToken(tokenList)\n      if (!identifierToken || identifierToken.type !== TokenTypes.IDENTIFIER) {\n        return false\n      }\n    }\n    const operatorToken = findNextRealToken(\n      tokenList,\n      findNextRealTokenIndex(tokenList) + (prevExpression ? 0 : 1)\n    )\n    return operatorToken && operatorToken.type === TokenTypes.OPERATOR_ASSIGNMENT\n  },\n\n  // NOTE BRN: The first token of a Statement cannot be Whitespace or a Comment\n  type: ParserTypes.EXPRESSION\n}\n\nexport default AssignmentExpression\n"],"file":"AssignmentExpression.js"}