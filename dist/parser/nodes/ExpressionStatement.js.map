{"version":3,"sources":["../../../src/parser/nodes/ExpressionStatement.js"],"names":["EXPRESSION_STATEMENT_PARSERS","Expression","Identifier","Literal","parseExpressionStatementTokens","parseExpression","parseWhitespaceAndComments","parseSemicolonOperator","createExpressionStatement","identifyExpressionStatementChildren","identifyExpression","skipWhitespaceAndComments","expectSemicolonOperator","ExpressionStatement","identify","context","node","children","is","value","type","NodeTypes","EXPRESSION_STATEMENT","parse","tokenList","test","ParserTypes","STATEMENT"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;AACA;;;;;;;;;;AAEA,MAAMA,4BAA4B,GAAG,CAACC,mBAAD,EAAaC,mBAAb,EAAyBC,gBAAzB,CAArC;AAEA,MAAMC,8BAA8B,GAAG,iBACrCC,wBADqC,EAErCC,mCAFqC,EAGrCC,+BAHqC,EAIrCC,kCAJqC,CAAvC;AAOA,MAAMC,mCAAmC,GAAG,iBAC1CC,2BAD0C,EAE1CC,kCAF0C,EAG1CC,gCAH0C,CAA5C;AAMA,MAAMC,mBAAmB,GAAG;AAC1BC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KACR,wEACKP,mCAAmC,iCACjCO,IADiC;AAEpCD,IAAAA;AAFoC,KADxC;AAKEE,IAAAA,QAAQ,EAAED,IAAI,CAACC;AALjB,KAFwB;AAS1BC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,oBATvB;AAW1BC,EAAAA,KAAK,EAAE,CAACR,OAAD,EAAUS,SAAV,KACLpB,8BAA8B,CAAC;AAAEa,IAAAA,QAAQ,EAAE,EAAZ;AAAgBF,IAAAA,OAAhB;AAAyBS,IAAAA;AAAzB,GAAD,CAZN;AAc1B;AACAC,EAAAA,IAAI,EAAE,CAACV,OAAD,EAAUS,SAAV,KAAwB,2BAAaxB,4BAAb,EAA2Ce,OAA3C,EAAoDS,SAApD,CAfJ;AAgB1BJ,EAAAA,IAAI,EAAEM,uBAAYC;AAhBQ,CAA5B;eAmBed,mB","sourcesContent":["import { pipe } from 'ramda'\n\nimport { NodeTypes, ParserTypes } from '../../constants'\nimport createExpressionStatement from '../pipes/createExpressionStatement'\nimport expectSemicolonOperator from '../pipes/expectSemicolonOperator'\nimport identifyExpression from '../pipes/identifyExpression'\nimport parseExpression from '../pipes/parseExpression'\nimport parseSemicolonOperator from '../pipes/parseSemicolonOperator'\nimport parseWhitespaceAndComments from '../pipes/parseWhitespaceAndComments'\nimport skipWhitespaceAndComments from '../pipes/skipWhitespaceAndComments'\nimport testNextNode from '../util/testNextNode'\n\nimport Expression from './Expression'\nimport Identifier from './Identifier'\nimport Literal from './Literal'\n\nconst EXPRESSION_STATEMENT_PARSERS = [Expression, Identifier, Literal]\n\nconst parseExpressionStatementTokens = pipe(\n  parseExpression,\n  parseWhitespaceAndComments,\n  parseSemicolonOperator,\n  createExpressionStatement\n)\n\nconst identifyExpressionStatementChildren = pipe(\n  identifyExpression,\n  skipWhitespaceAndComments,\n  expectSemicolonOperator\n)\n\nconst ExpressionStatement = {\n  identify: (context, node) =>\n    createExpressionStatement({\n      ...identifyExpressionStatementChildren({\n        ...node,\n        context\n      }),\n      children: node.children\n    }),\n  is: (value) => value && value.type === NodeTypes.EXPRESSION_STATEMENT,\n\n  parse: (context, tokenList) =>\n    parseExpressionStatementTokens({ children: [], context, tokenList }),\n\n  // NOTE BRN: The first token of a Statement cannot be Whitespace or a Comment\n  test: (context, tokenList) => testNextNode(EXPRESSION_STATEMENT_PARSERS, context, tokenList),\n  type: ParserTypes.STATEMENT\n}\n\nexport default ExpressionStatement\n"],"file":"ExpressionStatement.js"}