{"version":3,"sources":["../../../src/parser/nodes/BinaryExpression.js"],"names":["BINARY_OPERATOR_TOKEN_TYPES","TokenTypes","KEYWORD_IN","OperatorTypes","IN","KEYWORD_IS","IS","OPERATOR_DIVIDE","DIVIDE","OPERATOR_EQUALITY","EQUALITY","OPERATOR_GREATER_THAN","GREATER_THAN","OPERATOR_GREATER_THAN_EQUAL","GREATER_THAN_EQUAL","OPERATOR_INEQUALITY","INEQUALITY","OPERATOR_LESS_THAN","LESS_THAN","OPERATOR_LESS_THAN_EQUAL","LESS_THAN_EQUAL","OPERATOR_LOGICAL_AND","LOGICAL_AND","OPERATOR_LOGICAL_OR","LOGICAL_OR","OPERATOR_MODULUS","MODULUS","OPERATOR_MULTIPLY","MULTIPLY","OPERATOR_UNARY_MINUS","UNARY_MINUS","OPERATOR_UNARY_PLUS","UNARY_PLUS","parseBinaryExpressionTokens","parseLeft","parseWhitespaceAndComments","parseBinaryOperator","parseRight","createBinaryExpression","identifyBinaryExpressionChildren","identifyLeft","skipWhitespaceAndComments","identifyBinaryOperator","identifyRight","LEFT_PARSERS","Identifier","Literal","BinaryExpression","identify","context","node","children","is","value","type","NodeTypes","BINARY_EXPRESSION","parse","tokenList","prevExpression","test","operatorToken","ParserTypes","EXPRESSION"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;;;;;;;;;AAEA,MAAMA,2BAA2B,GAAG;AAClC,GAACC,sBAAWC,UAAZ,GAAyBC,yBAAcC,EADL;AAElC,GAACH,sBAAWI,UAAZ,GAAyBF,yBAAcG,EAFL;AAGlC,GAACL,sBAAWM,eAAZ,GAA8BJ,yBAAcK,MAHV;AAIlC,GAACP,sBAAWQ,iBAAZ,GAAgCN,yBAAcO,QAJZ;AAKlC,GAACT,sBAAWU,qBAAZ,GAAoCR,yBAAcS,YALhB;AAMlC,GAACX,sBAAWY,2BAAZ,GAA0CV,yBAAcW,kBANtB;AAOlC,GAACb,sBAAWc,mBAAZ,GAAkCZ,yBAAca,UAPd;AAQlC,GAACf,sBAAWgB,kBAAZ,GAAiCd,yBAAce,SARb;AASlC,GAACjB,sBAAWkB,wBAAZ,GAAuChB,yBAAciB,eATnB;AAUlC,GAACnB,sBAAWoB,oBAAZ,GAAmClB,yBAAcmB,WAVf;AAWlC,GAACrB,sBAAWsB,mBAAZ,GAAkCpB,yBAAcqB,UAXd;AAYlC,GAACvB,sBAAWwB,gBAAZ,GAA+BtB,yBAAcuB,OAZX;AAalC,GAACzB,sBAAW0B,iBAAZ,GAAgCxB,yBAAcyB,QAbZ;AAclC,GAAC3B,sBAAW4B,oBAAZ,GAAmC1B,yBAAc2B,WAdf;AAelC,GAAC7B,sBAAW8B,mBAAZ,GAAkC5B,yBAAc6B;AAfd,CAApC;AAkBA,MAAMC,2BAA2B,GAAG,iBAClCC,kBADkC,EAElCC,mCAFkC,EAGlCC,4BAHkC,EAIlCD,mCAJkC,EAKlCE,mBALkC,EAMlCC,+BANkC,CAApC;AASA,MAAMC,gCAAgC,GAAG,iBACvCC,qBADuC,EAEvCC,kCAFuC,EAGvCC,+BAHuC,EAIvCD,kCAJuC,EAKvCE,sBALuC,CAAzC;AAQA,MAAMC,YAAY,GAAG,CAACC,mBAAD,EAAaC,gBAAb,CAArB;AAEA,MAAMC,gBAAgB,GAAG;AACvBC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KACR,qEACKX,gCAAgC,iCAC9BW,IAD8B;AAEjCD,IAAAA;AAFiC,KADrC;AAKEE,IAAAA,QAAQ,EAAED,IAAI,CAACC;AALjB,KAFqB;AASvBC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,iBAT1B;AAUvBC,EAAAA,KAAK,EAAE,CAACR,OAAD,EAAUS,SAAV,EAAqBC,cAAc,GAAG,IAAtC,KACL1B,2BAA2B,CAAC;AAC1BkB,IAAAA,QAAQ,EAAE,EADgB;AAE1BF,IAAAA,OAF0B;AAG1BU,IAAAA,cAH0B;AAI1BD,IAAAA;AAJ0B,GAAD,CAXN;AAiBvBE,EAAAA,IAAI,EAAE,CAACX,OAAD,EAAUS,SAAV,EAAqBC,cAAc,GAAG,IAAtC,KAA+C;AACnD,QAAI,CAACA,cAAL,EAAqB;AACnB,UAAI,CAAC,wBAAaf,YAAb,EAA2BK,OAA3B,EAAoCS,SAApC,CAAL,EAAqD;AACnD,eAAO,KAAP;AACD;AACF;;AACD,UAAMG,aAAa,GAAG,6BACpBH,SADoB,EAEpB,kCAAuBA,SAAvB,KAAqCC,cAAc,GAAG,CAAH,GAAO,CAA1D,CAFoB,CAAtB;AAIA,WAAOE,aAAa,IAAI,gBAAIA,aAAa,CAACP,IAAlB,EAAwBtD,2BAAxB,CAAxB;AACD,GA5BsB;AA6BvBsD,EAAAA,IAAI,EAAEQ,uBAAYC;AA7BK,CAAzB;eAgCehB,gB","sourcesContent":["import { has, pipe } from 'ramda'\n\nimport { NodeTypes, OperatorTypes, ParserTypes, TokenTypes } from '../../constants'\nimport createBinaryExpression from '../pipes/createBinaryExpression'\nimport identifyBinaryOperator from '../pipes/identifyBinaryOperator'\nimport identifyLeft from '../pipes/identifyLeft'\nimport identifyRight from '../pipes/identifyRight'\nimport parseBinaryOperator from '../pipes/parseBinaryOperator'\nimport parseLeft from '../pipes/parseLeft'\nimport parseRight from '../pipes/parseRight'\nimport parseWhitespaceAndComments from '../pipes/parseWhitespaceAndComments'\nimport skipWhitespaceAndComments from '../pipes/skipWhitespaceAndComments'\nimport { findNextRealToken, findNextRealTokenIndex, testNextNode } from '../util'\n\nimport Identifier from './Identifier'\nimport Literal from './Literal'\n\nconst BINARY_OPERATOR_TOKEN_TYPES = {\n  [TokenTypes.KEYWORD_IN]: OperatorTypes.IN,\n  [TokenTypes.KEYWORD_IS]: OperatorTypes.IS,\n  [TokenTypes.OPERATOR_DIVIDE]: OperatorTypes.DIVIDE,\n  [TokenTypes.OPERATOR_EQUALITY]: OperatorTypes.EQUALITY,\n  [TokenTypes.OPERATOR_GREATER_THAN]: OperatorTypes.GREATER_THAN,\n  [TokenTypes.OPERATOR_GREATER_THAN_EQUAL]: OperatorTypes.GREATER_THAN_EQUAL,\n  [TokenTypes.OPERATOR_INEQUALITY]: OperatorTypes.INEQUALITY,\n  [TokenTypes.OPERATOR_LESS_THAN]: OperatorTypes.LESS_THAN,\n  [TokenTypes.OPERATOR_LESS_THAN_EQUAL]: OperatorTypes.LESS_THAN_EQUAL,\n  [TokenTypes.OPERATOR_LOGICAL_AND]: OperatorTypes.LOGICAL_AND,\n  [TokenTypes.OPERATOR_LOGICAL_OR]: OperatorTypes.LOGICAL_OR,\n  [TokenTypes.OPERATOR_MODULUS]: OperatorTypes.MODULUS,\n  [TokenTypes.OPERATOR_MULTIPLY]: OperatorTypes.MULTIPLY,\n  [TokenTypes.OPERATOR_UNARY_MINUS]: OperatorTypes.UNARY_MINUS,\n  [TokenTypes.OPERATOR_UNARY_PLUS]: OperatorTypes.UNARY_PLUS\n}\n\nconst parseBinaryExpressionTokens = pipe(\n  parseLeft,\n  parseWhitespaceAndComments,\n  parseBinaryOperator,\n  parseWhitespaceAndComments,\n  parseRight,\n  createBinaryExpression\n)\n\nconst identifyBinaryExpressionChildren = pipe(\n  identifyLeft,\n  skipWhitespaceAndComments,\n  identifyBinaryOperator,\n  skipWhitespaceAndComments,\n  identifyRight\n)\n\nconst LEFT_PARSERS = [Identifier, Literal]\n\nconst BinaryExpression = {\n  identify: (context, node) =>\n    createBinaryExpression({\n      ...identifyBinaryExpressionChildren({\n        ...node,\n        context\n      }),\n      children: node.children\n    }),\n  is: (value) => value && value.type === NodeTypes.BINARY_EXPRESSION,\n  parse: (context, tokenList, prevExpression = null) =>\n    parseBinaryExpressionTokens({\n      children: [],\n      context,\n      prevExpression,\n      tokenList\n    }),\n  test: (context, tokenList, prevExpression = null) => {\n    if (!prevExpression) {\n      if (!testNextNode(LEFT_PARSERS, context, tokenList)) {\n        return false\n      }\n    }\n    const operatorToken = findNextRealToken(\n      tokenList,\n      findNextRealTokenIndex(tokenList) + (prevExpression ? 0 : 1)\n    )\n    return operatorToken && has(operatorToken.type, BINARY_OPERATOR_TOKEN_TYPES)\n  },\n  type: ParserTypes.EXPRESSION\n}\n\nexport default BinaryExpression\n"],"file":"BinaryExpression.js"}