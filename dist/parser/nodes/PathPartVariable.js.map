{"version":3,"sources":["../../../src/parser/nodes/PathPartVariable.js"],"names":["parsePathPartVariableTokens","parseDivideOperator","parseOpenCurlyBraceOperator","parseWhitespaceAndComments","parseIdentifier","parseOptionalAssignmentOperator","parseOptionalMultiplyOperator","parseCloseCurlyBraceOperator","createPathPartVariable","identifyPathPartVariableChildren","expectDivideOperator","expectOpenCurlyBraceOperator","skipWhitespaceAndComments","identifyIdentifier","skipAssignmentOperator","skipMultiplyOperator","expectCloseCurlyBraceOperator","PathPartVariable","identify","context","node","children","is","value","type","NodeTypes","PATH_PART_VARIABLE","parse","tokenList","test","prevExpression","firstToken","get","secondToken","TokenTypes","OPERATOR_DIVIDE","OPERATOR_OPEN_CURLY_BRACE"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;AAEA,MAAMA,2BAA2B,GAAG,iBAClCC,4BADkC,EAElCC,oCAFkC,EAGlCC,mCAHkC,EAIlCC,wBAJkC,EAKlCC,wCALkC,EAMlCC,sCANkC,EAOlCA,sCAPkC,EAQlCH,mCARkC,EASlCI,qCATkC,EAUlCC,+BAVkC,CAApC;AAaA,MAAMC,gCAAgC,GAAG,iBACvCC,6BADuC,EAEvCC,qCAFuC,EAGvCC,kCAHuC,EAIvCC,2BAJuC,EAKvCC,+BALuC,EAMvCC,6BANuC,EAOvCA,6BAPuC,EAQvCH,kCARuC,EASvCI,sCATuC,CAAzC;AAYA,MAAMC,gBAAgB,GAAG;AACvBC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KACR,qEACKX,gCAAgC,iCAC9BW,IAD8B;AAEjCD,IAAAA;AAFiC,KADrC;AAKEE,IAAAA,QAAQ,EAAED,IAAI,CAACC;AALjB,KAFqB;AASvBC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,kBAT1B;AAUvBC,EAAAA,KAAK,EAAE,CAACR,OAAD,EAAUS,SAAV,KAAwB5B,2BAA2B,CAAC;AAAEqB,IAAAA,QAAQ,EAAE,EAAZ;AAAgBF,IAAAA,OAAhB;AAAyBS,IAAAA;AAAzB,GAAD,CAVnC;AAWvBC,EAAAA,IAAI,EAAE,CAACV,OAAD,EAAUS,SAAV,EAAqBE,cAAc,GAAG,IAAtC,KAA+C;AACnD,QAAIA,cAAJ,EAAoB;AAClB;AACA,aAAO,KAAP;AACD;;AACD,UAAMC,UAAU,GAAGH,SAAS,CAACI,GAAV,CAAc,CAAd,CAAnB;AACA,UAAMC,WAAW,GAAGL,SAAS,CAACI,GAAV,CAAc,CAAd,CAApB;AACA,WACED,UAAU,IACVA,UAAU,CAACP,IAAX,KAAoBU,sBAAWC,eAD/B,IAEAF,WAFA,IAGAA,WAAW,CAACT,IAAZ,KAAqBU,sBAAWE,yBAJlC;AAMD;AAxBsB,CAAzB;eA2BenB,gB","sourcesContent":["import { pipe } from 'ramda'\n\nimport { NodeTypes, TokenTypes } from '../../constants'\nimport createPathPartVariable from '../pipes/createPathPartVariable'\nimport expectCloseCurlyBraceOperator from '../pipes/expectCloseCurlyBraceOperator'\nimport expectDivideOperator from '../pipes/expectDivideOperator'\nimport expectOpenCurlyBraceOperator from '../pipes/expectOpenCurlyBraceOperator'\nimport identifyIdentifier from '../pipes/identifyIdentifier'\nimport parseCloseCurlyBraceOperator from '../pipes/parseCloseCurlyBraceOperator'\nimport parseDivideOperator from '../pipes/parseDivideOperator'\nimport parseIdentifier from '../pipes/parseIdentifier'\nimport parseOpenCurlyBraceOperator from '../pipes/parseOpenCurlyBraceOperator'\nimport parseOptionalAssignmentOperator from '../pipes/parseOptionalAssignmentOperator'\nimport parseOptionalMultiplyOperator from '../pipes/parseOptionalMultiplyOperator'\nimport parseWhitespaceAndComments from '../pipes/parseWhitespaceAndComments'\nimport skipAssignmentOperator from '../pipes/skipAssignmentOperator'\nimport skipMultiplyOperator from '../pipes/skipMultiplyOperator'\nimport skipWhitespaceAndComments from '../pipes/skipWhitespaceAndComments'\n\nconst parsePathPartVariableTokens = pipe(\n  parseDivideOperator,\n  parseOpenCurlyBraceOperator,\n  parseWhitespaceAndComments,\n  parseIdentifier,\n  parseOptionalAssignmentOperator,\n  parseOptionalMultiplyOperator,\n  parseOptionalMultiplyOperator,\n  parseWhitespaceAndComments,\n  parseCloseCurlyBraceOperator,\n  createPathPartVariable\n)\n\nconst identifyPathPartVariableChildren = pipe(\n  expectDivideOperator,\n  expectOpenCurlyBraceOperator,\n  skipWhitespaceAndComments,\n  identifyIdentifier,\n  skipAssignmentOperator,\n  skipMultiplyOperator,\n  skipMultiplyOperator,\n  skipWhitespaceAndComments,\n  expectCloseCurlyBraceOperator\n)\n\nconst PathPartVariable = {\n  identify: (context, node) =>\n    createPathPartVariable({\n      ...identifyPathPartVariableChildren({\n        ...node,\n        context\n      }),\n      children: node.children\n    }),\n  is: (value) => value && value.type === NodeTypes.PATH_PART_VARIABLE,\n  parse: (context, tokenList) => parsePathPartVariableTokens({ children: [], context, tokenList }),\n  test: (context, tokenList, prevExpression = null) => {\n    if (prevExpression) {\n      // In this case, it's a CallExpression\n      return false\n    }\n    const firstToken = tokenList.get(0)\n    const secondToken = tokenList.get(1)\n    return (\n      firstToken &&\n      firstToken.type === TokenTypes.OPERATOR_DIVIDE &&\n      secondToken &&\n      secondToken.type === TokenTypes.OPERATOR_OPEN_CURLY_BRACE\n    )\n  }\n}\n\nexport default PathPartVariable\n"],"file":"PathPartVariable.js"}