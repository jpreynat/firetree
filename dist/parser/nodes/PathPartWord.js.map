{"version":3,"sources":["../../../src/parser/nodes/PathPartWord.js"],"names":["parsePathPartWordTokens","parseDivideOperator","parseWord","createPathPartWord","identifyPathPartWordChildren","expectDivideOperator","identifyWord","PathPartWord","identify","context","node","children","is","value","type","NodeTypes","PATH_PART_WORD","parse","tokenList","test","prevExpression","firstToken","get","TokenTypes","OPERATOR_DIVIDE","Word"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;;;;;;;;;AAEA,MAAMA,uBAAuB,GAAG,iBAAKC,4BAAL,EAA0BC,kBAA1B,EAAqCC,2BAArC,CAAhC;AAEA,MAAMC,4BAA4B,GAAG,iBAAKC,6BAAL,EAA2BC,qBAA3B,CAArC;AAEA,MAAMC,YAAY,GAAG;AACnBC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KACR,iEACKN,4BAA4B,iCAC1BM,IAD0B;AAE7BD,IAAAA;AAF6B,KADjC;AAKEE,IAAAA,QAAQ,EAAED,IAAI,CAACC;AALjB,KAFiB;AASnBC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,cAT9B;AAUnBC,EAAAA,KAAK,EAAE,CAACR,OAAD,EAAUS,SAAV,KAAwBlB,uBAAuB,CAAC;AAAEW,IAAAA,QAAQ,EAAE,EAAZ;AAAgBF,IAAAA,OAAhB;AAAyBS,IAAAA;AAAzB,GAAD,CAVnC;AAWnBC,EAAAA,IAAI,EAAE,CAACV,OAAD,EAAUS,SAAV,EAAqBE,cAAc,GAAG,IAAtC,KAA+C;AACnD,QAAIA,cAAJ,EAAoB;AAClB;AACA,aAAO,KAAP;AACD;;AACD,UAAMC,UAAU,GAAGH,SAAS,CAACI,GAAV,CAAc,CAAd,CAAnB;AACA,WACED,UAAU,IACVA,UAAU,CAACP,IAAX,KAAoBS,sBAAWC,eAD/B,IAEAC,cAAKN,IAAL,CAAUV,OAAV,EAAmB,iBAAKS,SAAL,CAAnB,CAHF;AAKD;AAtBkB,CAArB;eAyBeX,Y","sourcesContent":["import { pipe, tail } from 'ramda'\n\nimport { NodeTypes, TokenTypes } from '../../constants'\nimport createPathPartWord from '../pipes/createPathPartWord'\nimport expectDivideOperator from '../pipes/expectDivideOperator'\nimport identifyWord from '../pipes/identifyWord'\nimport parseDivideOperator from '../pipes/parseDivideOperator'\nimport parseWord from '../pipes/parseWord'\n\nimport Word from './Word'\n\nconst parsePathPartWordTokens = pipe(parseDivideOperator, parseWord, createPathPartWord)\n\nconst identifyPathPartWordChildren = pipe(expectDivideOperator, identifyWord)\n\nconst PathPartWord = {\n  identify: (context, node) =>\n    createPathPartWord({\n      ...identifyPathPartWordChildren({\n        ...node,\n        context\n      }),\n      children: node.children\n    }),\n  is: (value) => value && value.type === NodeTypes.PATH_PART_WORD,\n  parse: (context, tokenList) => parsePathPartWordTokens({ children: [], context, tokenList }),\n  test: (context, tokenList, prevExpression = null) => {\n    if (prevExpression) {\n      // In this case, it's a BinaryExpress with a DivideOperator\n      return false\n    }\n    const firstToken = tokenList.get(0)\n    return (\n      firstToken &&\n      firstToken.type === TokenTypes.OPERATOR_DIVIDE &&\n      Word.test(context, tail(tokenList))\n    )\n  }\n}\n\nexport default PathPartWord\n"],"file":"PathPartWord.js"}