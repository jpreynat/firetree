{"version":3,"sources":["../../../src/parser/nodes/ConditionalExpression.js"],"names":["TEST_PARSERS","Identifier","Literal","parseConditionalExpressionTokens","parseTest","parseWhitespaceAndComments","parseQuestionMarkOperator","parseConsequent","parseColonOperator","parseAlternate","createConditionalExpression","identifyConditionalExpressionChildren","identifyTest","skipWhitespaceAndComments","expectQuestionMarkOperator","identifyConsequent","expectColonOperator","identifyAlternate","ConditionalExpression","identify","context","node","children","is","value","type","NodeTypes","CONDITIONAL_EXPRESSION","parse","tokenList","prevExpression","test","operatorToken","TokenTypes","OPERATOR_QUESTION_MARK","ParserTypes","EXPRESSION"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;;;;;;;;;AAEA,MAAMA,YAAY,GAAG,CAACC,mBAAD,EAAaC,gBAAb,CAArB;AAEA,MAAMC,gCAAgC,GAAG,iBACvCC,kBADuC,EAEvCC,mCAFuC,EAGvCC,kCAHuC,EAIvCD,mCAJuC,EAKvCE,wBALuC,EAMvCF,mCANuC,EAOvCG,2BAPuC,EAQvCH,mCARuC,EASvCI,uBATuC,EAUvCC,oCAVuC,CAAzC;AAaA,MAAMC,qCAAqC,GAAG,iBAC5CC,qBAD4C,EAE5CC,kCAF4C,EAG5CC,mCAH4C,EAI5CD,kCAJ4C,EAK5CE,2BAL4C,EAM5CF,kCAN4C,EAO5CG,4BAP4C,EAQ5CH,kCAR4C,EAS5CI,0BAT4C,CAA9C;AAYA,MAAMC,qBAAqB,GAAG;AAC5BC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KACR,0EACKV,qCAAqC,iCACnCU,IADmC;AAEtCD,IAAAA;AAFsC,KAD1C;AAKEE,IAAAA,QAAQ,EAAED,IAAI,CAACC;AALjB,KAF0B;AAS5BC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,sBATrB;AAU5BC,EAAAA,KAAK,EAAE,CAACR,OAAD,EAAUS,SAAV,EAAqBC,cAAc,GAAG,IAAtC,KACL3B,gCAAgC,CAAC;AAC/BmB,IAAAA,QAAQ,EAAE,EADqB;AAE/BF,IAAAA,OAF+B;AAG/BU,IAAAA,cAH+B;AAI/BD,IAAAA;AAJ+B,GAAD,CAXN;AAiB5BE,EAAAA,IAAI,EAAE,CAACX,OAAD,EAAUS,SAAV,EAAqBC,cAAc,GAAG,IAAtC,KAA+C;AACnD,QAAI,CAACA,cAAL,EAAqB;AACnB,UAAI,CAAC,wBAAa9B,YAAb,EAA2BoB,OAA3B,EAAoCS,SAApC,CAAL,EAAqD;AACnD,eAAO,KAAP;AACD;AACF;;AACD,UAAMG,aAAa,GAAG,6BACpBH,SADoB,EAEpB,kCAAuBA,SAAvB,KAAqCC,cAAc,GAAG,CAAH,GAAO,CAA1D,CAFoB,CAAtB;AAIA,WAAOE,aAAa,IAAIA,aAAa,CAACP,IAAd,KAAuBQ,sBAAWC,sBAA1D;AACD,GA5B2B;AA6B5BT,EAAAA,IAAI,EAAEU,uBAAYC;AA7BU,CAA9B;eAgCelB,qB","sourcesContent":["import { pipe } from 'ramda'\n\nimport { NodeTypes, ParserTypes, TokenTypes } from '../../constants'\nimport createConditionalExpression from '../pipes/createConditionalExpression'\nimport expectColonOperator from '../pipes/expectColonOperator'\nimport expectQuestionMarkOperator from '../pipes/expectQuestionMarkOperator'\nimport identifyAlternate from '../pipes/identifyAlternate'\nimport identifyConsequent from '../pipes/identifyConsequent'\nimport identifyTest from '../pipes/identifyTest'\nimport parseAlternate from '../pipes/parseAlternate'\nimport parseColonOperator from '../pipes/parseColonOperator'\nimport parseConsequent from '../pipes/parseConsequent'\nimport parseQuestionMarkOperator from '../pipes/parseQuestionMarkOperator'\nimport parseTest from '../pipes/parseTest'\nimport parseWhitespaceAndComments from '../pipes/parseWhitespaceAndComments'\nimport skipWhitespaceAndComments from '../pipes/skipWhitespaceAndComments'\nimport { findNextRealToken, findNextRealTokenIndex, testNextNode } from '../util'\n\nimport Identifier from './Identifier'\nimport Literal from './Literal'\n\nconst TEST_PARSERS = [Identifier, Literal]\n\nconst parseConditionalExpressionTokens = pipe(\n  parseTest,\n  parseWhitespaceAndComments,\n  parseQuestionMarkOperator,\n  parseWhitespaceAndComments,\n  parseConsequent,\n  parseWhitespaceAndComments,\n  parseColonOperator,\n  parseWhitespaceAndComments,\n  parseAlternate,\n  createConditionalExpression\n)\n\nconst identifyConditionalExpressionChildren = pipe(\n  identifyTest,\n  skipWhitespaceAndComments,\n  expectQuestionMarkOperator,\n  skipWhitespaceAndComments,\n  identifyConsequent,\n  skipWhitespaceAndComments,\n  expectColonOperator,\n  skipWhitespaceAndComments,\n  identifyAlternate\n)\n\nconst ConditionalExpression = {\n  identify: (context, node) =>\n    createConditionalExpression({\n      ...identifyConditionalExpressionChildren({\n        ...node,\n        context\n      }),\n      children: node.children\n    }),\n  is: (value) => value && value.type === NodeTypes.CONDITIONAL_EXPRESSION,\n  parse: (context, tokenList, prevExpression = null) =>\n    parseConditionalExpressionTokens({\n      children: [],\n      context,\n      prevExpression,\n      tokenList\n    }),\n  test: (context, tokenList, prevExpression = null) => {\n    if (!prevExpression) {\n      if (!testNextNode(TEST_PARSERS, context, tokenList)) {\n        return false\n      }\n    }\n    const operatorToken = findNextRealToken(\n      tokenList,\n      findNextRealTokenIndex(tokenList) + (prevExpression ? 0 : 1)\n    )\n    return operatorToken && operatorToken.type === TokenTypes.OPERATOR_QUESTION_MARK\n  },\n  type: ParserTypes.EXPRESSION\n}\n\nexport default ConditionalExpression\n"],"file":"ConditionalExpression.js"}