{"version":3,"sources":["../../../src/parser/nodes/Literal.js"],"names":["Literal","identify","context","node","is","value","type","NodeTypes","LITERAL","parse","tokenList","identifier","get","id","raw","TokenTypes","BYTES","Buffer","from","eval","substring","length","test","firstToken","IDENTIFIER","NUMBER","STRING"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AAEA;;AAEA,MAAMA,OAAO,GAAG;AACdC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KAAmBA,IADf;AAEdC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,OAF1B;AAGdC,EAAAA,KAAK,EAAE,CAACP,OAAD,EAAUQ,SAAV,KAAwB;AAC7B,UAAMC,UAAU,GAAGD,SAAS,CAACE,GAAV,CAAc,CAAd,CAAnB;AACA,WAAO;AACLC,MAAAA,EAAE,EAAE,eADC;AAELC,MAAAA,GAAG,EAAEH,UAAU,CAACN,KAFX;AAGLK,MAAAA,SAAS,EAAE,kBAAM,CAAN,EAAS,CAAT,EAAYA,SAAZ,CAHN;AAILJ,MAAAA,IAAI,EAAEC,qBAAUC,OAJX;AAKLH,MAAAA,KAAK,EACHM,UAAU,CAACL,IAAX,KAAoBS,sBAAWC,KAA/B,GACIC,eAAOC,IAAP,CAAYC,IAAI,CAACR,UAAU,CAACN,KAAX,CAAiBe,SAAjB,CAA2B,CAA3B,EAA8BT,UAAU,CAACN,KAAX,CAAiBgB,MAA/C,CAAD,CAAhB,CADJ,GAEIF,IAAI,CAACR,UAAU,CAACN,KAAZ;AARL,KAAP;AAUD,GAfa;AAgBdiB,EAAAA,IAAI,EAAE,CAACpB,OAAD,EAAUQ,SAAV,KAAwB;AAC5B,UAAMa,UAAU,GAAGb,SAAS,CAACE,GAAV,CAAc,CAAd,CAAnB;AACA,WACEW,UAAU,MACV;AACEA,IAAAA,UAAU,CAACjB,IAAX,KAAoBS,sBAAWS,UAA/B,KACCD,UAAU,CAAClB,KAAX,KAAqB,MAArB,IACCkB,UAAU,CAAClB,KAAX,KAAqB,OADtB,IAECkB,UAAU,CAAClB,KAAX,KAAqB,MAHvB,CAAD,IAIC;AACAkB,IAAAA,UAAU,CAACjB,IAAX,KAAoBS,sBAAWC,KALhC,IAMC;AACAO,IAAAA,UAAU,CAACjB,IAAX,KAAoBS,sBAAWU,MAPhC,IAQC;AACAF,IAAAA,UAAU,CAACjB,IAAX,KAAoBS,sBAAWW,MAXvB,CADZ;AAcD;AAhCa,CAAhB;eAmCe1B,O","sourcesContent":["import { Buffer } from 'buffer'\n\nimport { slice } from 'ramda'\nimport { v4 as uuidv4 } from 'uuid'\n\nimport { NodeTypes, TokenTypes } from '../../constants'\n\nconst Literal = {\n  identify: (context, node) => node,\n  is: (value) => value.type === NodeTypes.LITERAL,\n  parse: (context, tokenList) => {\n    const identifier = tokenList.get(0)\n    return {\n      id: uuidv4(),\n      raw: identifier.value,\n      tokenList: slice(0, 1, tokenList),\n      type: NodeTypes.LITERAL,\n      value:\n        identifier.type === TokenTypes.BYTES\n          ? Buffer.from(eval(identifier.value.substring(1, identifier.value.length)))\n          : eval(identifier.value)\n    }\n  },\n  test: (context, tokenList) => {\n    const firstToken = tokenList.get(0)\n    return (\n      firstToken &&\n      // Booleans & Null\n      ((firstToken.type === TokenTypes.IDENTIFIER &&\n        (firstToken.value === 'true' ||\n          firstToken.value === 'false' ||\n          firstToken.value === 'null')) ||\n        // Bytes\n        firstToken.type === TokenTypes.BYTES ||\n        // Numbers\n        firstToken.type === TokenTypes.NUMBER ||\n        // Strings\n        firstToken.type === TokenTypes.STRING)\n    )\n  }\n}\n\nexport default Literal\n"],"file":"Literal.js"}