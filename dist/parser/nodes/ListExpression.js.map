{"version":3,"sources":["../../../src/parser/nodes/ListExpression.js"],"names":["parseListExpressionTokens","parseOpenBracketOperator","parseWhitespaceAndComments","parseElements","parseCloseBracketOperator","createListExpression","identifyListExpressionChildren","expectOpenBracketOperator","skipWhitespaceAndComments","identifyElements","expectCloseBracketOperator","ListExpression","identify","context","node","children","is","value","type","NodeTypes","LIST_EXPRESSION","parse","tokenList","test","prevExpression","operatorToken","TokenTypes","OPERATOR_OPEN_BRACKET","ParserTypes","EXPRESSION"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;AAEA,MAAMA,yBAAyB,GAAG,iBAChCC,iCADgC,EAEhCC,mCAFgC,EAGhCC,sBAHgC,EAIhCD,mCAJgC,EAKhCE,kCALgC,EAMhCC,6BANgC,CAAlC;AASA,MAAMC,8BAA8B,GAAG,iBACrCC,kCADqC,EAErCC,kCAFqC,EAGrCC,yBAHqC,EAIrCD,kCAJqC,EAKrCE,mCALqC,CAAvC;AAQA,MAAMC,cAAc,GAAG;AACrBC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KACR,mEACKR,8BAA8B,iCAC5BQ,IAD4B;AAE/BD,IAAAA;AAF+B,KADnC;AAKEE,IAAAA,QAAQ,EAAED,IAAI,CAACC;AALjB,KAFmB;AASrBC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,eAT5B;AAUrBC,EAAAA,KAAK,EAAE,CAACR,OAAD,EAAUS,SAAV,KAAwBtB,yBAAyB,CAAC;AAAEe,IAAAA,QAAQ,EAAE,EAAZ;AAAgBF,IAAAA,OAAhB;AAAyBS,IAAAA;AAAzB,GAAD,CAVnC;AAWrBC,EAAAA,IAAI,EAAE,CAACV,OAAD,EAAUS,SAAV,EAAqBE,cAAc,GAAG,IAAtC,KAA+C;AACnD,QAAIA,cAAJ,EAAoB;AAClB;AACA,aAAO,KAAP;AACD;;AACD,UAAMC,aAAa,GAAG,6BAAkBH,SAAlB,EAA6B,kCAAuBA,SAAvB,CAA7B,CAAtB;AACA,WAAOG,aAAa,IAAIA,aAAa,CAACP,IAAd,KAAuBQ,sBAAWC,qBAA1D;AACD,GAlBoB;AAmBrBT,EAAAA,IAAI,EAAEU,uBAAYC;AAnBG,CAAvB;eAsBelB,c","sourcesContent":["import { pipe } from 'ramda'\n\nimport { NodeTypes, ParserTypes, TokenTypes } from '../../constants'\nimport createListExpression from '../pipes/createListExpression'\nimport expectCloseBracketOperator from '../pipes/expectCloseBracketOperator'\nimport expectOpenBracketOperator from '../pipes/expectOpenBracketOperator'\nimport identifyElements from '../pipes/identifyElements'\nimport parseCloseBracketOperator from '../pipes/parseCloseBracketOperator'\nimport parseElements from '../pipes/parseElements'\nimport parseOpenBracketOperator from '../pipes/parseOpenBracketOperator'\nimport parseWhitespaceAndComments from '../pipes/parseWhitespaceAndComments'\nimport skipWhitespaceAndComments from '../pipes/skipWhitespaceAndComments'\nimport { findNextRealToken, findNextRealTokenIndex } from '../util'\n\nconst parseListExpressionTokens = pipe(\n  parseOpenBracketOperator,\n  parseWhitespaceAndComments,\n  parseElements,\n  parseWhitespaceAndComments,\n  parseCloseBracketOperator,\n  createListExpression\n)\n\nconst identifyListExpressionChildren = pipe(\n  expectOpenBracketOperator,\n  skipWhitespaceAndComments,\n  identifyElements,\n  skipWhitespaceAndComments,\n  expectCloseBracketOperator\n)\n\nconst ListExpression = {\n  identify: (context, node) =>\n    createListExpression({\n      ...identifyListExpressionChildren({\n        ...node,\n        context\n      }),\n      children: node.children\n    }),\n  is: (value) => value && value.type === NodeTypes.LIST_EXPRESSION,\n  parse: (context, tokenList) => parseListExpressionTokens({ children: [], context, tokenList }),\n  test: (context, tokenList, prevExpression = null) => {\n    if (prevExpression) {\n      // In this case, it's a ComputedMemberExpression\n      return false\n    }\n    const operatorToken = findNextRealToken(tokenList, findNextRealTokenIndex(tokenList))\n    return operatorToken && operatorToken.type === TokenTypes.OPERATOR_OPEN_BRACKET\n  },\n  type: ParserTypes.EXPRESSION\n}\n\nexport default ListExpression\n"],"file":"ListExpression.js"}