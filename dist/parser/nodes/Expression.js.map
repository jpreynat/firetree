{"version":3,"sources":["../../../src/parser/nodes/Expression.js"],"names":["Expression","identify","context","node","rest","Expressions","type","Error","is","value","NodeTypes","ASSIGNMENT_EXPRESSION","BINARY_EXPRESSION","CALL_EXPRESSION","COMPUTED_MEMBER_EXPRESSION","CONDITIONAL_EXPRESSION","LIST_EXPRESSION","MAP_EXPRESSION","PARENTHESES_EXPRESSION","PATH_EXPRESSION","STATIC_MEMBER_EXPRESSION","UNARY_EXPRESSION","parse","tokenList","prevExpression","expression","parsedTokenList","ast","nextTokenList","size","test"],"mappings":";;;;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;;;AAEA,MAAMA,UAAU,GAAG;AACjBC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,EAAgB,GAAGC,IAAnB,KAA4B;AACpC,UAAM;AAAEC,MAAAA;AAAF,QAAkBH,OAAxB;AACA,UAAMI,IAAI,GAAG,yBAAeD,WAAf,EAA4BF,IAA5B,CAAb;;AACA,QAAI,CAACG,IAAL,EAAW;AACT,YAAM,IAAIC,KAAJ,CAAW,sCAAqCJ,IAAK,EAArD,CAAN;AACD;;AACD,WAAOG,IAAI,CAACL,QAAL,CAAcC,OAAd,EAAuBC,IAAvB,EAA6B,GAAGC,IAAhC,CAAP;AACD,GARgB;AASjBI,EAAAA,EAAE,EAAGC,KAAD,IACF;AACA;AACA;AACAA,EAAAA,KAAK,CAACH,IAAN,KAAeI,qBAAUC,qBAAzB,IACAF,KAAK,CAACH,IAAN,KAAeI,qBAAUE,iBADzB,IAEAH,KAAK,CAACH,IAAN,KAAeI,qBAAUG,eAFzB,IAGAJ,KAAK,CAACH,IAAN,KAAeI,qBAAUI,0BAHzB,IAIAL,KAAK,CAACH,IAAN,KAAeI,qBAAUK,sBAJzB,IAKAN,KAAK,CAACH,IAAN,KAAeI,qBAAUM,eALzB,IAMAP,KAAK,CAACH,IAAN,KAAeI,qBAAUO,cANzB,IAOAR,KAAK,CAACH,IAAN,KAAeI,qBAAUQ,sBAPzB,IAQAT,KAAK,CAACH,IAAN,KAAeI,qBAAUS,eARzB,IASAV,KAAK,CAACH,IAAN,KAAeI,qBAAUU,wBATzB,IAUAX,KAAK,CAACH,IAAN,KAAeI,qBAAUW,gBAvBV;AAwBjBC,EAAAA,KAAK,EAAE,CAACpB,OAAD,EAAUqB,SAAV,EAAqBC,cAAc,GAAG,IAAtC,KAA+C;AACpD,QAAIC,UAAU,GAAG,4BAAcvB,OAAO,CAACG,WAAtB,EAAmCH,OAAnC,EAA4CqB,SAA5C,EAAuDC,cAAvD,CAAjB;AACA,QAAIE,eAAe,GAAG,gCAAkBxB,OAAlB,EAA2B;AAAEyB,MAAAA,GAAG,EAAEF;AAAP,KAA3B,CAAtB;AACA,QAAIG,aAAa,GAAG,kBAAMF,eAAe,CAACG,IAAtB,EAA4BN,SAAS,CAACM,IAAtC,EAA4CN,SAA5C,CAApB;;AACA,WAAO,2BAAarB,OAAO,CAACG,WAArB,EAAkCH,OAAlC,EAA2C0B,aAA3C,EAA0DH,UAA1D,CAAP,EAA8E;AAC5EA,MAAAA,UAAU,GAAG,4BAAcvB,OAAO,CAACG,WAAtB,EAAmCH,OAAnC,EAA4C0B,aAA5C,EAA2DH,UAA3D,CAAb;AACAC,MAAAA,eAAe,GAAG,gCAAkBxB,OAAlB,EAA2B;AAAEyB,QAAAA,GAAG,EAAEF;AAAP,OAA3B,CAAlB;AACAG,MAAAA,aAAa,GAAG,kBAAMF,eAAe,CAACG,IAAtB,EAA4BN,SAAS,CAACM,IAAtC,EAA4CN,SAA5C,CAAhB;AACD;;AACD,WAAOE,UAAP;AACD,GAlCgB;AAoCjB;AACAK,EAAAA,IAAI,EAAE,CAAC5B,OAAD,EAAUqB,SAAV,EAAqBC,cAAc,GAAG,IAAtC,KACJ,2BAAatB,OAAO,CAACG,WAArB,EAAkCH,OAAlC,EAA2CqB,SAA3C,EAAsDC,cAAtD;AAtCe,CAAnB;eAyCexB,U","sourcesContent":["import { slice } from 'ramda'\n\nimport { findIdentifier } from '../../ast'\nimport { NodeTypes } from '../../constants'\nimport generateTokenList from '../../generator/generateTokenList'\nimport parseNextNode from '../util/parseNextNode'\nimport testNextNode from '../util/testNextNode'\n\nconst Expression = {\n  identify: (context, node, ...rest) => {\n    const { Expressions } = context\n    const type = findIdentifier(Expressions, node)\n    if (!type) {\n      throw new Error(`Could not find Expression Node for ${node}`)\n    }\n    return type.identify(context, node, ...rest)\n  },\n  is: (value) =>\n    // TODO BRN: This is pretty hacky and doesn't leave room for expansion.\n    // Instead it would be better if the NodeType was EXPRESSION and then\n    // we had a sub expressionType\n    value.type === NodeTypes.ASSIGNMENT_EXPRESSION ||\n    value.type === NodeTypes.BINARY_EXPRESSION ||\n    value.type === NodeTypes.CALL_EXPRESSION ||\n    value.type === NodeTypes.COMPUTED_MEMBER_EXPRESSION ||\n    value.type === NodeTypes.CONDITIONAL_EXPRESSION ||\n    value.type === NodeTypes.LIST_EXPRESSION ||\n    value.type === NodeTypes.MAP_EXPRESSION ||\n    value.type === NodeTypes.PARENTHESES_EXPRESSION ||\n    value.type === NodeTypes.PATH_EXPRESSION ||\n    value.type === NodeTypes.STATIC_MEMBER_EXPRESSION ||\n    value.type === NodeTypes.UNARY_EXPRESSION,\n  parse: (context, tokenList, prevExpression = null) => {\n    let expression = parseNextNode(context.Expressions, context, tokenList, prevExpression)\n    let parsedTokenList = generateTokenList(context, { ast: expression })\n    let nextTokenList = slice(parsedTokenList.size, tokenList.size, tokenList)\n    while (testNextNode(context.Expressions, context, nextTokenList, expression)) {\n      expression = parseNextNode(context.Expressions, context, nextTokenList, expression)\n      parsedTokenList = generateTokenList(context, { ast: expression })\n      nextTokenList = slice(parsedTokenList.size, tokenList.size, tokenList)\n    }\n    return expression\n  },\n\n  // NOTE BRN: The first token of an Expression cannot be Whitespace or a Comment\n  test: (context, tokenList, prevExpression = null) =>\n    testNextNode(context.Expressions, context, tokenList, prevExpression)\n}\n\nexport default Expression\n"],"file":"Expression.js"}