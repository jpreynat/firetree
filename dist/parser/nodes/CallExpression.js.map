{"version":3,"sources":["../../../src/parser/nodes/CallExpression.js"],"names":["parseCallExpressionTokens","parseCallee","parseWhitespaceAndComments","parseArgs","createCallExpression","identifyCallExpressionChildren","identifyCallee","skipWhitespaceAndComments","identifyArgs","CallExpression","identify","context","node","children","is","value","type","NodeTypes","CALL_EXPRESSION","parse","tokenList","prevExpression","test","identifierToken","TokenTypes","IDENTIFIER","operatorToken","OPERATOR_OPEN_PARENTHESIS","ParserTypes","EXPRESSION"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;AAEA,MAAMA,yBAAyB,GAAG,iBAChCC,oBADgC,EAEhCC,mCAFgC,EAGhCC,kBAHgC,EAIhCC,6BAJgC,CAAlC;AAOA,MAAMC,8BAA8B,GAAG,iBAAKC,uBAAL,EAAqBC,kCAArB,EAAgDC,qBAAhD,CAAvC;AAEA,MAAMC,cAAc,GAAG;AACrBC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KACR,mEACKP,8BAA8B,iCAC5BO,IAD4B;AAE/BD,IAAAA;AAF+B,KADnC;AAKEE,IAAAA,QAAQ,EAAED,IAAI,CAACC;AALjB,KAFmB;AASrBC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,eAT5B;AAUrBC,EAAAA,KAAK,EAAE,CAACR,OAAD,EAAUS,SAAV,EAAqBC,cAAc,GAAG,IAAtC,KACLrB,yBAAyB,CAAC;AACxBa,IAAAA,QAAQ,EAAE,EADc;AAExBF,IAAAA,OAFwB;AAGxBU,IAAAA,cAHwB;AAIxBD,IAAAA;AAJwB,GAAD,CAXN;AAkBrBE,EAAAA,IAAI,EAAE,CAACX,OAAD,EAAUS,SAAV,EAAqBC,cAAc,GAAG,IAAtC,KAA+C;AACnD,QAAI,CAACA,cAAL,EAAqB;AACnB,YAAME,eAAe,GAAG,6BAAkBH,SAAlB,CAAxB;;AACA,UAAI,CAACG,eAAD,IAAoBA,eAAe,CAACP,IAAhB,KAAyBQ,sBAAWC,UAA5D,EAAwE;AACtE,eAAO,KAAP;AACD;AACF;;AACD,UAAMC,aAAa,GAAG,6BACpBN,SADoB,EAEpB,kCAAuBA,SAAvB,KAAqCC,cAAc,GAAG,CAAH,GAAO,CAA1D,CAFoB,CAAtB;AAIA,WAAOK,aAAa,IAAIA,aAAa,CAACV,IAAd,KAAuBQ,sBAAWG,yBAA1D;AACD,GA9BoB;AA+BrBX,EAAAA,IAAI,EAAEY,uBAAYC;AA/BG,CAAvB;eAkCepB,c","sourcesContent":["import { pipe } from 'ramda'\n\nimport { NodeTypes, ParserTypes, TokenTypes } from '../../constants'\nimport createCallExpression from '../pipes/createCallExpression'\nimport identifyArgs from '../pipes/identifyArgs'\nimport identifyCallee from '../pipes/identifyCallee'\nimport parseArgs from '../pipes/parseArgs'\nimport parseCallee from '../pipes/parseCallee'\nimport parseWhitespaceAndComments from '../pipes/parseWhitespaceAndComments'\nimport skipWhitespaceAndComments from '../pipes/skipWhitespaceAndComments'\nimport { findNextRealToken, findNextRealTokenIndex } from '../util'\n\nconst parseCallExpressionTokens = pipe(\n  parseCallee,\n  parseWhitespaceAndComments,\n  parseArgs,\n  createCallExpression\n)\n\nconst identifyCallExpressionChildren = pipe(identifyCallee, skipWhitespaceAndComments, identifyArgs)\n\nconst CallExpression = {\n  identify: (context, node) =>\n    createCallExpression({\n      ...identifyCallExpressionChildren({\n        ...node,\n        context\n      }),\n      children: node.children\n    }),\n  is: (value) => value && value.type === NodeTypes.CALL_EXPRESSION,\n  parse: (context, tokenList, prevExpression = null) =>\n    parseCallExpressionTokens({\n      children: [],\n      context,\n      prevExpression,\n      tokenList\n    }),\n\n  test: (context, tokenList, prevExpression = null) => {\n    if (!prevExpression) {\n      const identifierToken = findNextRealToken(tokenList)\n      if (!identifierToken || identifierToken.type !== TokenTypes.IDENTIFIER) {\n        return false\n      }\n    }\n    const operatorToken = findNextRealToken(\n      tokenList,\n      findNextRealTokenIndex(tokenList) + (prevExpression ? 0 : 1)\n    )\n    return operatorToken && operatorToken.type === TokenTypes.OPERATOR_OPEN_PARENTHESIS\n  },\n  type: ParserTypes.EXPRESSION\n}\n\nexport default CallExpression\n"],"file":"CallExpression.js"}