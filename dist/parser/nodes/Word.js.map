{"version":3,"sources":["../../../src/parser/nodes/Word.js"],"names":["WORD_TOKEN_TYPES","TokenTypes","IDENTIFIER","KEYWORD_ALLOW","KEYWORD_FUNCTION","KEYWORD_IF","KEYWORD_IS","KEYWORD_LET","KEYWORD_MATCH","KEYWORD_RETURN","KEYWORD_SERVICE","OPERATOR_AMPERSAND","OPERATOR_AT_SIGN","OPERATOR_COLON","OPERATOR_DOT","OPERATOR_MODULUS","OPERATOR_MULTIPLY","OPERATOR_TILDE","OPERATOR_UNARY_MINUS","OPERATOR_UNARY_PLUS","Word","identify","context","node","is","value","type","NodeTypes","WORD","parse","tokenList","nextToken","get","Error","lastLineCharacterCount","lineCount","wordTokenList","size","push","test"],"mappings":";;;;;;;AAAA;;AACA;;AAEA;;AACA;;AACA;;;;AAEA,MAAMA,gBAAgB,GAAG;AACvB,GAACC,sBAAWC,UAAZ,GAAyB,IADF;AAEvB,GAACD,sBAAWE,aAAZ,GAA4B,IAFL;AAGvB,GAACF,sBAAWG,gBAAZ,GAA+B,IAHR;AAIvB,GAACH,sBAAWI,UAAZ,GAAyB,IAJF;AAKvB,GAACJ,sBAAWK,UAAZ,GAAyB,IALF;AAMvB,GAACL,sBAAWM,WAAZ,GAA0B,IANH;AAOvB,GAACN,sBAAWO,aAAZ,GAA4B,IAPL;AAQvB,GAACP,sBAAWQ,cAAZ,GAA6B,IARN;AASvB,GAACR,sBAAWS,eAAZ,GAA8B,IATP;AAUvB,GAACT,sBAAWU,kBAAZ,GAAiC,IAVV;AAWvB,GAACV,sBAAWW,gBAAZ,GAA+B,IAXR;AAYvB,GAACX,sBAAWY,cAAZ,GAA6B,IAZN;AAavB,GAACZ,sBAAWa,YAAZ,GAA2B,IAbJ;AAcvB,GAACb,sBAAWc,gBAAZ,GAA+B,IAdR;AAevB,GAACd,sBAAWe,iBAAZ,GAAgC,IAfT;AAgBvB,GAACf,sBAAWgB,cAAZ,GAA6B,IAhBN;AAiBvB,GAAChB,sBAAWiB,oBAAZ,GAAmC,IAjBZ;AAkBvB,GAACjB,sBAAWkB,mBAAZ,GAAkC;AAlBX,CAAzB;AAqBA,MAAMC,IAAI,GAAG;AACXC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KAAmBA,IADlB;AAEXC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,IAFtC;AAGXC,EAAAA,KAAK,EAAE,CAACP,OAAD,EAAUQ,SAAV,KAAwB;AAC7B,QAAIC,SAAS,GAAGD,SAAS,CAACE,GAAV,CAAc,CAAd,CAAhB;;AACA,QAAI,CAACD,SAAL,EAAgB;AACd,YAAM,IAAIE,KAAJ,CAAW,4EAAX,CAAN;AACD;;AACD,QAAI,CAAC,gBAAIF,SAAS,CAACL,IAAd,EAAoB1B,gBAApB,CAAL,EAA4C;AAC1C,YAAM;AAAEkC,QAAAA,sBAAF;AAA0BC,QAAAA;AAA1B,UAAwC,gCAAqBb,OAArB,EAA8BQ,SAA9B,CAA9C;AACA,YAAM,IAAIG,KAAJ,CACH,6DACCH,SAAS,CAACE,GAAV,CAAc,CAAd,EAAiBP,KAClB,QAAOU,SAAU,IAAGD,sBAAuB,EAHxC,CAAN;AAKD;;AACD,QAAIE,aAAa,GAAG,sBAApB;;AACA,WAAON,SAAS,CAACO,IAAV,GAAiB,CAAjB,IAAsB,gBAAIN,SAAS,CAACL,IAAd,EAAoB1B,gBAApB,CAA7B,EAAoE;AAClEoC,MAAAA,aAAa,GAAGA,aAAa,CAACE,IAAd,CAAmBP,SAAnB,CAAhB;AACAD,MAAAA,SAAS,GAAG,iBAAKA,SAAL,CAAZ;AACAC,MAAAA,SAAS,GAAGD,SAAS,CAACE,GAAV,CAAc,CAAd,CAAZ;AACD;;AACD,WAAO,yBAAW;AAAEF,MAAAA,SAAS,EAAEM;AAAb,KAAX,CAAP;AACD,GAvBU;AAwBXG,EAAAA,IAAI,EAAE,CAACjB,OAAD,EAAUQ,SAAV,KAAwB,gBAAIA,SAAS,CAACE,GAAV,CAAc,CAAd,EAAiBN,IAArB,EAA2B1B,gBAA3B;AAxBnB,CAAb;eA2BeoB,I","sourcesContent":["import { List } from 'immutable'\nimport { has, tail } from 'ramda'\n\nimport { NodeTypes, TokenTypes } from '../../constants'\nimport createWord from '../pipes/createWord'\nimport { getTokenListPosition } from '../util'\n\nconst WORD_TOKEN_TYPES = {\n  [TokenTypes.IDENTIFIER]: true,\n  [TokenTypes.KEYWORD_ALLOW]: true,\n  [TokenTypes.KEYWORD_FUNCTION]: true,\n  [TokenTypes.KEYWORD_IF]: true,\n  [TokenTypes.KEYWORD_IS]: true,\n  [TokenTypes.KEYWORD_LET]: true,\n  [TokenTypes.KEYWORD_MATCH]: true,\n  [TokenTypes.KEYWORD_RETURN]: true,\n  [TokenTypes.KEYWORD_SERVICE]: true,\n  [TokenTypes.OPERATOR_AMPERSAND]: true,\n  [TokenTypes.OPERATOR_AT_SIGN]: true,\n  [TokenTypes.OPERATOR_COLON]: true,\n  [TokenTypes.OPERATOR_DOT]: true,\n  [TokenTypes.OPERATOR_MODULUS]: true,\n  [TokenTypes.OPERATOR_MULTIPLY]: true,\n  [TokenTypes.OPERATOR_TILDE]: true,\n  [TokenTypes.OPERATOR_UNARY_MINUS]: true,\n  [TokenTypes.OPERATOR_UNARY_PLUS]: true\n}\n\nconst Word = {\n  identify: (context, node) => node,\n  is: (value) => value && value.type === NodeTypes.WORD,\n  parse: (context, tokenList) => {\n    let nextToken = tokenList.get(0)\n    if (!nextToken) {\n      throw new Error(`Expected one of 'a-zA-Z0-9_-@~&*+%:.' Instead reached the end of the file.`)\n    }\n    if (!has(nextToken.type, WORD_TOKEN_TYPES)) {\n      const { lastLineCharacterCount, lineCount } = getTokenListPosition(context, tokenList)\n      throw new Error(\n        `Expected one of 'a-zA-Z0-9_-@~&*+%:.'. Instead was given '${\n          tokenList.get(0).value\n        }' at ${lineCount}:${lastLineCharacterCount}`\n      )\n    }\n    let wordTokenList = List()\n    while (tokenList.size > 0 && has(nextToken.type, WORD_TOKEN_TYPES)) {\n      wordTokenList = wordTokenList.push(nextToken)\n      tokenList = tail(tokenList)\n      nextToken = tokenList.get(0)\n    }\n    return createWord({ tokenList: wordTokenList })\n  },\n  test: (context, tokenList) => has(tokenList.get(0).type, WORD_TOKEN_TYPES)\n}\n\nexport default Word\n"],"file":"Word.js"}