{"version":3,"sources":["../../../src/parser/nodes/UnaryExpression.js"],"names":["UNARY_OPERATOR_TOKEN_TYPES","TokenTypes","OPERATOR_LOGICAL_NOT","OperatorTypes","LOGICAL_NOT","OPERATOR_UNARY_MINUS","UNARY_MINUS","OPERATOR_UNARY_PLUS","UNARY_PLUS","parseUnaryExpressionTokens","parseOperator","parseWhitespaceAndComments","parseArgument","createUnaryExpression","identifyUnaryExpressionChildren","identifyOperator","skipWhitespaceAndComments","identifyArgument","UnaryExpression","identify","context","node","children","is","value","type","NodeTypes","UNARY_EXPRESSION","parse","tokenList","prevExpression","test","get","ParserTypes","EXPRESSION"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;AAEA,MAAMA,0BAA0B,GAAG;AACjC,GAACC,sBAAWC,oBAAZ,GAAmCC,yBAAcC,WADhB;AAEjC,GAACH,sBAAWI,oBAAZ,GAAmCF,yBAAcG,WAFhB;AAGjC,GAACL,sBAAWM,mBAAZ,GAAkCJ,yBAAcK;AAHf,CAAnC;AAMA,MAAMC,0BAA0B,GAAG,iBACjCC,sBADiC,EAEjCC,mCAFiC,EAGjCC,sBAHiC,EAIjCC,8BAJiC,CAAnC;AAOA,MAAMC,+BAA+B,GAAG,iBACtCC,yBADsC,EAEtCC,kCAFsC,EAGtCC,yBAHsC,CAAxC;AAMA,MAAMC,eAAe,GAAG;AACtBC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KACR,oEACKP,+BAA+B,iCAC7BO,IAD6B;AAEhCD,IAAAA;AAFgC,KADpC;AAKEE,IAAAA,QAAQ,EAAED,IAAI,CAACC;AALjB,KAFoB;AAStBC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,gBAT3B;AAUtBC,EAAAA,KAAK,EAAE,CAACR,OAAD,EAAUS,SAAV,EAAqBC,cAAc,GAAG,IAAtC,KACLrB,0BAA0B,CAAC;AACzBa,IAAAA,QAAQ,EAAE,EADe;AAEzBF,IAAAA,OAFyB;AAGzBU,IAAAA,cAHyB;AAIzBD,IAAAA;AAJyB,GAAD,CAXN;AAiBtBE,EAAAA,IAAI,EAAE,CAACX,OAAD,EAAUS,SAAV,EAAqBC,cAAc,GAAG,IAAtC,KACJ,CAACA,cAAD,IAAmB,gBAAID,SAAS,CAACG,GAAV,CAAc,CAAd,EAAiBP,IAArB,EAA2BzB,0BAA3B,CAlBC;AAmBtByB,EAAAA,IAAI,EAAEQ,uBAAYC;AAnBI,CAAxB;eAsBehB,e","sourcesContent":["import { has, pipe } from 'ramda'\n\nimport { NodeTypes, OperatorTypes, ParserTypes, TokenTypes } from '../../constants'\nimport createUnaryExpression from '../pipes/createUnaryExpression'\nimport identifyArgument from '../pipes/identifyArgument'\nimport identifyOperator from '../pipes/identifyOperator'\nimport parseArgument from '../pipes/parseArgument'\nimport parseOperator from '../pipes/parseOperator'\nimport parseWhitespaceAndComments from '../pipes/parseWhitespaceAndComments'\nimport skipWhitespaceAndComments from '../pipes/skipWhitespaceAndComments'\n\nconst UNARY_OPERATOR_TOKEN_TYPES = {\n  [TokenTypes.OPERATOR_LOGICAL_NOT]: OperatorTypes.LOGICAL_NOT,\n  [TokenTypes.OPERATOR_UNARY_MINUS]: OperatorTypes.UNARY_MINUS,\n  [TokenTypes.OPERATOR_UNARY_PLUS]: OperatorTypes.UNARY_PLUS\n}\n\nconst parseUnaryExpressionTokens = pipe(\n  parseOperator,\n  parseWhitespaceAndComments,\n  parseArgument,\n  createUnaryExpression\n)\n\nconst identifyUnaryExpressionChildren = pipe(\n  identifyOperator,\n  skipWhitespaceAndComments,\n  identifyArgument\n)\n\nconst UnaryExpression = {\n  identify: (context, node) =>\n    createUnaryExpression({\n      ...identifyUnaryExpressionChildren({\n        ...node,\n        context\n      }),\n      children: node.children\n    }),\n  is: (value) => value && value.type === NodeTypes.UNARY_EXPRESSION,\n  parse: (context, tokenList, prevExpression = null) =>\n    parseUnaryExpressionTokens({\n      children: [],\n      context,\n      prevExpression,\n      tokenList\n    }),\n  test: (context, tokenList, prevExpression = null) =>\n    !prevExpression && has(tokenList.get(0).type, UNARY_OPERATOR_TOKEN_TYPES),\n  type: ParserTypes.EXPRESSION\n}\n\nexport default UnaryExpression\n"],"file":"UnaryExpression.js"}