{"version":3,"sources":["../../../src/parser/nodes/ComputedMemberExpression.js"],"names":["parseComputedMemberExpressionTokens","parseObject","parseWhitespaceAndComments","parseOpenBracketOperator","parseProperty","parseCloseBracketOperator","createComputedMemberExpression","identifyComputedMemberExpressionChildren","identifyObject","skipWhitespaceAndComments","expectOpenBracketOperator","identifyProperty","expectCloseBracketOperator","ComputedMemberExpression","identify","context","node","children","is","value","type","NodeTypes","COMPUTED_MEMBER_EXPRESSION","parse","tokenList","prevExpression","test","identifierToken","TokenTypes","IDENTIFIER","operatorToken","OPERATOR_OPEN_BRACKET","ParserTypes","EXPRESSION"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;AAEA,MAAMA,mCAAmC,GAAG,iBAC1CC,oBAD0C,EAE1CC,mCAF0C,EAG1CC,iCAH0C,EAI1CD,mCAJ0C,EAK1CE,sBAL0C,EAM1CF,mCAN0C,EAO1CG,kCAP0C,EAQ1CC,uCAR0C,CAA5C;AAWA,MAAMC,wCAAwC,GAAG,iBAC/CC,uBAD+C,EAE/CC,kCAF+C,EAG/CC,kCAH+C,EAI/CD,kCAJ+C,EAK/CE,yBAL+C,EAM/CF,kCAN+C,EAO/CG,mCAP+C,CAAjD;AAUA,MAAMC,wBAAwB,GAAG;AAC/BC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KACR,6EACKT,wCAAwC,iCACtCS,IADsC;AAEzCD,IAAAA;AAFyC,KAD7C;AAKEE,IAAAA,QAAQ,EAAED,IAAI,CAACC;AALjB,KAF6B;AAS/BC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,0BATlB;AAU/BC,EAAAA,KAAK,EAAE,CAACR,OAAD,EAAUS,SAAV,EAAqBC,cAAc,GAAG,IAAtC,KACLzB,mCAAmC,CAAC;AAClCiB,IAAAA,QAAQ,EAAE,EADwB;AAElCF,IAAAA,OAFkC;AAGlCU,IAAAA,cAHkC;AAIlCD,IAAAA;AAJkC,GAAD,CAXN;AAiB/BE,EAAAA,IAAI,EAAE,CAACX,OAAD,EAAUS,SAAV,EAAqBC,cAAc,GAAG,IAAtC,KAA+C;AACnD,QAAI,CAACA,cAAL,EAAqB;AACnB,YAAME,eAAe,GAAG,6BAAkBH,SAAlB,CAAxB;;AACA,UAAI,CAACG,eAAD,IAAoBA,eAAe,CAACP,IAAhB,KAAyBQ,sBAAWC,UAA5D,EAAwE;AACtE,eAAO,KAAP;AACD;AACF;;AACD,UAAMC,aAAa,GAAG,6BACpBN,SADoB,EAEpB,kCAAuBA,SAAvB,KAAqCC,cAAc,GAAG,CAAH,GAAO,CAA1D,CAFoB,CAAtB;AAIA,WAAOK,aAAa,IAAIA,aAAa,CAACV,IAAd,KAAuBQ,sBAAWG,qBAA1D;AACD,GA7B8B;AA8B/BX,EAAAA,IAAI,EAAEY,uBAAYC;AA9Ba,CAAjC;eAiCepB,wB","sourcesContent":["import { pipe } from 'ramda'\n\nimport { NodeTypes, ParserTypes, TokenTypes } from '../../constants'\nimport createComputedMemberExpression from '../pipes/createComputedMemberExpression'\nimport expectCloseBracketOperator from '../pipes/expectCloseBracketOperator'\nimport expectOpenBracketOperator from '../pipes/expectOpenBracketOperator'\nimport identifyObject from '../pipes/identifyObject'\nimport identifyProperty from '../pipes/identifyProperty'\nimport parseCloseBracketOperator from '../pipes/parseCloseBracketOperator'\nimport parseObject from '../pipes/parseObject'\nimport parseOpenBracketOperator from '../pipes/parseOpenBracketOperator'\nimport parseProperty from '../pipes/parseProperty'\nimport parseWhitespaceAndComments from '../pipes/parseWhitespaceAndComments'\nimport skipWhitespaceAndComments from '../pipes/skipWhitespaceAndComments'\nimport { findNextRealToken, findNextRealTokenIndex } from '../util'\n\nconst parseComputedMemberExpressionTokens = pipe(\n  parseObject,\n  parseWhitespaceAndComments,\n  parseOpenBracketOperator,\n  parseWhitespaceAndComments,\n  parseProperty,\n  parseWhitespaceAndComments,\n  parseCloseBracketOperator,\n  createComputedMemberExpression\n)\n\nconst identifyComputedMemberExpressionChildren = pipe(\n  identifyObject,\n  skipWhitespaceAndComments,\n  expectOpenBracketOperator,\n  skipWhitespaceAndComments,\n  identifyProperty,\n  skipWhitespaceAndComments,\n  expectCloseBracketOperator\n)\n\nconst ComputedMemberExpression = {\n  identify: (context, node) =>\n    createComputedMemberExpression({\n      ...identifyComputedMemberExpressionChildren({\n        ...node,\n        context\n      }),\n      children: node.children\n    }),\n  is: (value) => value && value.type === NodeTypes.COMPUTED_MEMBER_EXPRESSION,\n  parse: (context, tokenList, prevExpression = null) =>\n    parseComputedMemberExpressionTokens({\n      children: [],\n      context,\n      prevExpression,\n      tokenList\n    }),\n  test: (context, tokenList, prevExpression = null) => {\n    if (!prevExpression) {\n      const identifierToken = findNextRealToken(tokenList)\n      if (!identifierToken || identifierToken.type !== TokenTypes.IDENTIFIER) {\n        return false\n      }\n    }\n    const operatorToken = findNextRealToken(\n      tokenList,\n      findNextRealTokenIndex(tokenList) + (prevExpression ? 0 : 1)\n    )\n    return operatorToken && operatorToken.type === TokenTypes.OPERATOR_OPEN_BRACKET\n  },\n  type: ParserTypes.EXPRESSION\n}\n\nexport default ComputedMemberExpression\n"],"file":"ComputedMemberExpression.js"}