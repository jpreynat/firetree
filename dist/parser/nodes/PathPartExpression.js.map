{"version":3,"sources":["../../../src/parser/nodes/PathPartExpression.js"],"names":["parsePathPartExpressionTokens","parseDivideOperator","parseDollarSignOperator","parseOpenParenthesisOperator","parseWhitespaceAndComments","parseExpression","parseCloseParenthesisOperator","createPathPartExpression","identifyPathPartExpressionChildren","expectDivideOperator","expectDollarSignOperator","expectOpenParenthesisOperator","skipWhitespaceAndComments","identifyExpression","expectCloseParenthesisOperator","PathPartExpression","identify","context","node","children","is","value","type","NodeTypes","PATH_PART_EXPRESSION","parse","tokenList","test","prevExpression","firstToken","get","secondToken","thirdToken","TokenTypes","OPERATOR_DIVIDE","OPERATOR_DOLLAR_SIGN","OPERATOR_OPEN_PARENTHESIS"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;AAEA,MAAMA,6BAA6B,GAAG,iBACpCC,4BADoC,EAEpCC,gCAFoC,EAGpCC,qCAHoC,EAIpCC,mCAJoC,EAKpCC,wBALoC,EAMpCD,mCANoC,EAOpCE,sCAPoC,EAQpCC,iCARoC,CAAtC;AAWA,MAAMC,kCAAkC,GAAG,iBACzCC,6BADyC,EAEzCC,iCAFyC,EAGzCC,sCAHyC,EAIzCC,kCAJyC,EAKzCC,2BALyC,EAMzCD,kCANyC,EAOzCE,uCAPyC,EAQzCP,iCARyC,CAA3C;AAWA,MAAMQ,kBAAkB,GAAG;AACzBC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,KACR,uEACKV,kCAAkC,iCAChCU,IADgC;AAEnCD,IAAAA;AAFmC,KADvC;AAKEE,IAAAA,QAAQ,EAAED,IAAI,CAACC;AALjB,KAFuB;AASzBC,EAAAA,EAAE,EAAGC,KAAD,IAAWA,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeC,qBAAUC,oBATxB;AAUzBC,EAAAA,KAAK,EAAE,CAACR,OAAD,EAAUS,SAAV,KACL1B,6BAA6B,CAAC;AAAEmB,IAAAA,QAAQ,EAAE,EAAZ;AAAgBF,IAAAA,OAAhB;AAAyBS,IAAAA;AAAzB,GAAD,CAXN;AAYzBC,EAAAA,IAAI,EAAE,CAACV,OAAD,EAAUS,SAAV,EAAqBE,cAAc,GAAG,IAAtC,KAA+C;AACnD,QAAIA,cAAJ,EAAoB;AAClB;AACA,aAAO,KAAP;AACD;;AACD,UAAMC,UAAU,GAAGH,SAAS,CAACI,GAAV,CAAc,CAAd,CAAnB;AACA,UAAMC,WAAW,GAAGL,SAAS,CAACI,GAAV,CAAc,CAAd,CAApB;AACA,UAAME,UAAU,GAAGN,SAAS,CAACI,GAAV,CAAc,CAAd,CAAnB;AACA,WACED,UAAU,IACVA,UAAU,CAACP,IAAX,KAAoBW,sBAAWC,eAD/B,IAEAH,WAFA,IAGAA,WAAW,CAACT,IAAZ,KAAqBW,sBAAWE,oBAHhC,IAIAH,UAJA,IAKAA,UAAU,CAACV,IAAX,KAAoBW,sBAAWG,yBANjC;AAQD;AA5BwB,CAA3B;eA+BerB,kB","sourcesContent":["import { pipe } from 'ramda'\n\nimport { NodeTypes, TokenTypes } from '../../constants'\nimport createPathPartExpression from '../pipes/createPathPartExpression'\nimport expectCloseParenthesisOperator from '../pipes/expectCloseParenthesisOperator'\nimport expectDivideOperator from '../pipes/expectDivideOperator'\nimport expectDollarSignOperator from '../pipes/expectDollarSignOperator'\nimport expectOpenParenthesisOperator from '../pipes/expectOpenParenthesisOperator'\nimport identifyExpression from '../pipes/identifyExpression'\nimport parseCloseParenthesisOperator from '../pipes/parseCloseParenthesisOperator'\nimport parseDivideOperator from '../pipes/parseDivideOperator'\nimport parseDollarSignOperator from '../pipes/parseDollarSignOperator'\nimport parseExpression from '../pipes/parseExpression'\nimport parseOpenParenthesisOperator from '../pipes/parseOpenParenthesisOperator'\nimport parseWhitespaceAndComments from '../pipes/parseWhitespaceAndComments'\nimport skipWhitespaceAndComments from '../pipes/skipWhitespaceAndComments'\n\nconst parsePathPartExpressionTokens = pipe(\n  parseDivideOperator,\n  parseDollarSignOperator,\n  parseOpenParenthesisOperator,\n  parseWhitespaceAndComments,\n  parseExpression,\n  parseWhitespaceAndComments,\n  parseCloseParenthesisOperator,\n  createPathPartExpression\n)\n\nconst identifyPathPartExpressionChildren = pipe(\n  expectDivideOperator,\n  expectDollarSignOperator,\n  expectOpenParenthesisOperator,\n  skipWhitespaceAndComments,\n  identifyExpression,\n  skipWhitespaceAndComments,\n  expectCloseParenthesisOperator,\n  createPathPartExpression\n)\n\nconst PathPartExpression = {\n  identify: (context, node) =>\n    createPathPartExpression({\n      ...identifyPathPartExpressionChildren({\n        ...node,\n        context\n      }),\n      children: node.children\n    }),\n  is: (value) => value && value.type === NodeTypes.PATH_PART_EXPRESSION,\n  parse: (context, tokenList) =>\n    parsePathPartExpressionTokens({ children: [], context, tokenList }),\n  test: (context, tokenList, prevExpression = null) => {\n    if (prevExpression) {\n      // In this case, it's a CallExpression\n      return false\n    }\n    const firstToken = tokenList.get(0)\n    const secondToken = tokenList.get(1)\n    const thirdToken = tokenList.get(2)\n    return (\n      firstToken &&\n      firstToken.type === TokenTypes.OPERATOR_DIVIDE &&\n      secondToken &&\n      secondToken.type === TokenTypes.OPERATOR_DOLLAR_SIGN &&\n      thirdToken &&\n      thirdToken.type === TokenTypes.OPERATOR_OPEN_PARENTHESIS\n    )\n  }\n}\n\nexport default PathPartExpression\n"],"file":"PathPartExpression.js"}