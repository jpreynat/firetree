{"version":3,"sources":["../../../src/parser/nodes/Statement.js"],"names":["Statement","identify","context","node","rest","Statements","type","Error","is","value","NodeTypes","ALLOW_STATEMENT","EXPRESSION_STATEMENT","IF_STATEMENT","MATCH_STATEMENT","RETURN_STATEMENT","SERVICE_STATEMENT","parse","tokenList","test"],"mappings":";;;;;;;;;AAAA;;AACA;;AACA;;AACA;;;;AAEA,MAAMA,SAAS,GAAG;AAChBC,EAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,IAAV,EAAgB,GAAGC,IAAnB,KAA4B;AACpC,UAAM;AAAEC,MAAAA;AAAF,QAAiBH,OAAvB;AACA,UAAMI,IAAI,GAAG,yBAAeD,UAAf,EAA2BF,IAA3B,CAAb;;AACA,QAAI,CAACG,IAAL,EAAW;AACT,YAAM,IAAIC,KAAJ,CAAW,2CAA0CJ,IAAK,EAA1D,CAAN;AACD;;AACD,WAAOG,IAAI,CAACL,QAAL,CAAcC,OAAd,EAAuBC,IAAvB,EAA6B,GAAGC,IAAhC,CAAP;AACD,GARe;AAShBI,EAAAA,EAAE,EAAGC,KAAD,IACF;AACA;AACA;AACAA,EAAAA,KAAK,CAACH,IAAN,KAAeI,qBAAUC,eAAzB,IACA;AACAF,EAAAA,KAAK,CAACH,IAAN,KAAeI,qBAAUE,oBAFzB,IAGAH,KAAK,CAACH,IAAN,KAAeI,qBAAUG,YAHzB,IAIAJ,KAAK,CAACH,IAAN,KAAeI,qBAAUI,eAJzB,IAKAL,KAAK,CAACH,IAAN,KAAeI,qBAAUK,gBALzB,IAMAN,KAAK,CAACH,IAAN,KAAeI,qBAAUM,iBAnBX;AAoBhBC,EAAAA,KAAK,EAAE,CAACf,OAAD,EAAUgB,SAAV,KAAwB;AAC7B,WAAO,4BAAchB,OAAO,CAACG,UAAtB,EAAkCH,OAAlC,EAA2CgB,SAA3C,CAAP;AACD,GAtBe;AAwBhB;AACAC,EAAAA,IAAI,EAAE,CAACjB,OAAD,EAAUgB,SAAV,KAAwB,2BAAahB,OAAO,CAACG,UAArB,EAAiCH,OAAjC,EAA0CgB,SAA1C;AAzBd,CAAlB;eA4BelB,S","sourcesContent":["import { findIdentifier } from '../../ast'\nimport { NodeTypes } from '../../constants'\nimport parseNextNode from '../util/parseNextNode'\nimport testNextNode from '../util/testNextNode'\n\nconst Statement = {\n  identify: (context, node, ...rest) => {\n    const { Statements } = context\n    const type = findIdentifier(Statements, node)\n    if (!type) {\n      throw new Error(`Could not find Statement Identifier for ${node}`)\n    }\n    return type.identify(context, node, ...rest)\n  },\n  is: (value) =>\n    // TODO BRN: This is pretty hacky and doesn't leave room for expansion.\n    // Instead it would be better if the NodeType was EXPRESSION and then\n    // we had a sub expressionType\n    value.type === NodeTypes.ALLOW_STATEMENT ||\n    // value.type === NodeTypes.BLOCK_STATEMENT ||\n    value.type === NodeTypes.EXPRESSION_STATEMENT ||\n    value.type === NodeTypes.IF_STATEMENT ||\n    value.type === NodeTypes.MATCH_STATEMENT ||\n    value.type === NodeTypes.RETURN_STATEMENT ||\n    value.type === NodeTypes.SERVICE_STATEMENT,\n  parse: (context, tokenList) => {\n    return parseNextNode(context.Statements, context, tokenList)\n  },\n\n  // NOTE BRN: The first token of a Statement cannot be Whitespace or a Comment\n  test: (context, tokenList) => testNextNode(context.Statements, context, tokenList)\n}\n\nexport default Statement\n"],"file":"Statement.js"}